<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:ops="http://www.idpf.org/2007/ops" xml:lang="ja">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <link rel="stylesheet" type="text/css" href="style.css" />
  <meta name="generator" content="ReVIEW" />
  <title>テストピラミッド</title>
</head>
<body>
<h1><a id="h"></a>テストピラミッド</h1>
<div class="lead">
<p>Martin Fowler's blikiの&quot;<a href="http://martinfowler.com/bliki/TestPyramid.html" class="link">TestPyramid</a>&quot;の翻訳。</p>
</div>
<p>1 May 2012</p>
<p class="flushright">tags: <a href="http://martinfowler.com/tags/testing.html" class="link">testing</a></p>
<p>テストピラミッドは<a href="http://www.mountaingoatsoftware.com/" class="link">Mike Cohn</a>が考えた概念で、彼の著書<a href="http://www.amazon.com/dp/product/0321579364/" class="link">Succeeding with Agile</a>に説明がある。そのポイントは、低水準のユニットテストのほうが、GUI経由で実行する高水準のエンドツーエンドテストよりもずっと多くないといけないということだ。</p>
<div class="image">
<img src="images/pyramid.png" alt="" />
</div>
<p>これまでの私の経験では、テストを自動化するというのは、そのアプリケーションをユーザーインターフェイス経由で実行するという意味だった。テスト自動化ツールの多くには、アプリケーションの操作を記録する機能があった。そして、記録した操作を再生して、アプリケーションが同じ結果を返すかどうかを確かめたのだ。このやり方は、最初のうちはうまくいっていた。操作を記録するのは簡単だし、プログラミングの知識がない人でも操作を記録できた。</p>
<p>でも、この手法はあっという間に問題を引き起こし、<a href="http://watirmelon.com/2012/01/31/introducing-the-software-testing-ice-cream-cone/" class="link">「アイスクリームのコーン」</a>みたいな状態になってしまう。こんなふうにUI経由でテストをすると、ビルドに時間がかかるようになってしまう。テスト自動化ソフトの中には、ライセンスをインストールしないと使えないものも多い。つまり、特定のマシンでしかテストを実行できないってことだ。この手のソフトの多くは、いわゆる「ヘッドレス」モードでの実行が難しい。なので、スクリプトで監視させてデプロイメントパイプラインに組み込むこともできない。</p>
<p>いちばん重要なのは、この手のテストが壊れやすくなってしまうということだ。システムに機能を追加したりすると、いとも簡単に大量のテストが動かなくなってしまう。そして、もういちど記録をし直す必要が出てくる。記録・再生型のツールを使うのをあきらめれば、この問題も少しはましになる。しかし、テストを書くのは難しくなる。<a href="#fn-fn01">*1</a>この手のテストの書き方にいくら気をつけたところで、エンドツーエンドテストは<a href="http://martinfowler.com/articles/nonDeterminism.html" class="link">非決定論的な問題</a>になる傾向がある。つまり、信頼性が徐々に下がっていくということだ。要するに、UIを使って実行するエンドツーエンドテストというのは、こわれやすいし書くのも難しいし、さらに実行にも時間がかかるという代物になる。つまり、このピラミッドが主張するのは、テストの自動化に力を入れるのなら、昔ながらのGUIベースのテストよりも、ユニットテストのほうにもっと力を入れるべきだと言うことだ。</p>
<p>このピラミッドでは、中間層のテストも提唱している。アプリケーションのサービス層をテストするもので、私はこれを<a href="http://martinfowler.com/bliki/SubcutaneousTest.html" class="link">皮下テスト</a>と呼んでいる。皮下テストはエンドツーエンドテストのメリットの多くをもたらすだけでなく、UIフレームワークを使うことによる複雑性も回避できる。Webアプリケーションの場合、皮下テストに対応するのはAPIレイヤーを使ったテストだ。一方、ピラミッドの頂点にあるUIのテストに対応するのは、<a href="http://seleniumhq.org/" class="link">Selenium</a>やSahiなどを使ったテストだ。</p>
<p>テストピラミッドはアジャイル開発におけるテストでの認知度も高まってきた。その主なメッセージは伝わっているが、よりバランスのとれたテストポートフォリオを作るために、もう少し言っておきたい。In particular a common problem is that teams conflate the concepts of end-to-end tests, UI tests, and customer facing tests. These are all orthogonal characteristics. For example a rich javascript UI should have most of its UI behavior tested with javascript unit tests using something like <a href="http://pivotal.github.com/jasmine/" class="link">Jasmine</a>. A complex set of business rules could have tests captured in a customer-facing form, but run just on the relevant module much as unit tests are.</p>
<p>私が常々言っていることがある。高水準のテストというのは、テストでの守りにおける第二ラインになっているということだ。高水準のテストに失敗したということは、単にその機能の実装コードにバグがあるというだけのことではない。それに関するユニットテストが足りないということも意味するのだ。つまり、失敗したエンドツーエンドテストに対応するときには、同時にユニットテストも追加しなければいけない。</p>
<div class="footnote"><p class="footnote">[<a id="fn-fn01">*1</a>] Record-playback tools are almost always a bad idea for any kind of automation, since they resist changeability and obstruct useful abstractions. They are only worth having as a tool to generate fragments of scripts which you can then edit as a proper programming language, in the manner of <a href="http://www.thoughtworks-studios.com/twist-agile-testing" class="link">Twist</a> or <a href="http://www.gnu.org/software/emacs/manual/html_node/emacs/Save-Keyboard-Macro.html" class="link">Emacs</a>.</p></div>
</body>
</html>
