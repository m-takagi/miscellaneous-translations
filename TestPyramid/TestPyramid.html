<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:ops="http://www.idpf.org/2007/ops" xml:lang="ja">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <link rel="stylesheet" type="text/css" href="style.css" />
  <meta name="generator" content="ReVIEW" />
  <title>テストピラミッド</title>
</head>
<body>
<h1><a id="h"></a>テストピラミッド</h1>
<div class="lead">
<p>Martin Fowler's blikiの&quot;<a href="http://martinfowler.com/bliki/TestPyramid.html" class="link">TestPyramid</a>&quot;の翻訳。</p>
</div>
<p>1 May 2012</p>
<p class="flushright">tags: <a href="http://martinfowler.com/tags/testing.html" class="link">testing</a></p>
<p>テストピラミッドは<a href="http://www.mountaingoatsoftware.com/" class="link">Mike Cohn</a>が考えた概念で、彼の著書<a href="http://www.amazon.com/dp/product/0321579364/" class="link">Succeeding with Agile</a>に説明がある。そのポイントは、低水準のユニットテストのほうが、GUI経由で実行する高水準のエンドツーエンドテストよりもずっと多くないといけないということだ。</p>
<div class="image">
<img src="images/pyramid.png" alt="" />
</div>
<p>For much of my career test automation meant tests that drove an application through its user-interface. Such tools would often provide the facility to record an interaction with the application and then allow you to play back that interaction, checking that the application returned the same results. Such an approach works well initially. It's easy to record tests, and the tests can be recorded by people with no knowledge of programming.</p>
<p>But this kind of approach quickly runs into trouble, becoming an <a href="http://watirmelon.com/2012/01/31/introducing-the-software-testing-ice-cream-cone/" class="link">ice-cream cone</a>. Testing through the UI like this is slow, increasing build times. Often it requires installed licences for the test automation software, which means it can only be done on particular machines. Usually these cannot easily be run in a &quot;headless&quot; mode, monitored by scripts to put in a proper deployment pipeline.</p>
<p>Most importantly such tests are very brittle. An enhancement to the system can easily end up breaking lots of such tests, which then have to be re-recorded. You can reduce this problem by abandoning record-playback tools, but that makes the tests harder to write. <a href="#fn-fn01">*1</a> Even with good practices on writing them, end-to-end tests are more prone to <a href="http://martinfowler.com/articles/nonDeterminism.html" class="link">non-determinism problems</a>, which can undermine trust in them. In short, tests that run end-to-end through the UI are: brittle, expensive to write, and time consuming to run. So the pyramid argues that you should do much more automated testing through unit tests than you should through traditional GUI based testing.</p>
<p>The pyramid also argues for an intermediate layer of tests that act through a service layer of an application, what I refer to as <a href="http://martinfowler.com/bliki/SubcutaneousTest.html" class="link">SubcutaneousTests</a>. These can provide many of the advantages of end-to-end tests but avoid many of the complexities of dealing with UI frameworks. In web applications this would correspond to testing through an API layer while the top UI part of the pyramid would correspond to tests using something like <a href="http://seleniumhq.org/" class="link">Selenium</a> or Sahi.</p>
<p>The test pyramid comes up a lot in Agile testing circles and while its core message is sound, there is much more to say about building a well-balanced test portfolio. In particular a common problem is that teams conflate the concepts of end-to-end tests, UI tests, and customer facing tests. These are all orthogonal characteristics. For example a rich javascript UI should have most of its UI behavior tested with javascript unit tests using something like <a href="http://pivotal.github.com/jasmine/" class="link">Jasmine</a>. A complex set of business rules could have tests captured in a customer-facing form, but run just on the relevant module much as unit tests are.</p>
<p>In particular I always argue that high-level tests are there as a second line of test defense. If you get a failure in a high level test, not just do you have a bug in your functional code, you also have a missing unit test. Thus whenever you fix a failing end-to-end test, you should be adding unit tests too.</p>
<div class="footnote"><p class="footnote">[<a id="fn-fn01">*1</a>] Record-playback tools are almost always a bad idea for any kind of automation, since they resist changeability and obstruct useful abstractions. They are only worth having as a tool to generate fragments of scripts which you can then edit as a proper programming language, in the manner of <a href="http://www.thoughtworks-studios.com/twist-agile-testing" class="link">Twist</a> or <a href="http://www.gnu.org/software/emacs/manual/html_node/emacs/Save-Keyboard-Macro.html" class="link">Emacs</a>.</p></div>
</body>
</html>
