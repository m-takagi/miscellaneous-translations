<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:ops="http://www.idpf.org/2007/ops" xml:lang="ja">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <link rel="stylesheet" type="text/css" href="style.css" />
  <meta name="generator" content="ReVIEW" />
  <title>透過的コンパイル</title>
</head>
<body>
<h1><a id="h1"></a>第1章　透過的コンパイル</h1>
<div class="lead">
<p>Martin Fowler's blikiの&quot;<a href="http://martinfowler.com/bliki/TransparentCompilation.html" class="link">TransparentCompilation</a>&quot;の翻訳。</p>
</div>
<p>2013/2/12</p>
<p class="flushright">tags: <a href="http://martinfowler.com/tags/language%20feature.html" class="link">language feature</a></p>
<p>Web開発者たちの間で、<a href="http://coffeescript.org" class="link">CoffeeScript</a>や<a href="http://sass-lang.com" class="link">SCSS</a>といった言語の人気が高まりつつある。コンパイルして別言語のテキストに変換し、それをブラウザで実行させるというものだ。ソースコードからソースコードを生成するコンパイラ（またの名をトランスパイラ<a href="#fn-f01">*1</a>）は別に目新しいものではない。C++が登場したころによく使われていた<a href="http://ja.wikipedia.org/wiki/Cfront" class="link">Cfront</a>は、C++からCのコードを生成するものだった。しかし私に言わせると、CoffeeScriptやSCSSはそんなのとは違う。<em>透過的な</em>コンパイラだ。</p>
<p>コンパイラを使うとき、ふつうははコンパイラの生成結果をあまり気にしない。ソース言語で書いた内容に従って動く限り、生成結果は単なるビットの塊みたいなものだ。でも、ブラウザで動かすJavaScriptを生成するのなら、そんな無関心ではやっていけない。最近は気のきいたデバッグ環境も出てきたようだが、結局のところはHTML/CSS/JavaScriptの三要素になる。なので、ソース言語で書いた内容がどんなふうにターゲットに変換されるのかを知っておくことが大切だ。</p>
<p>この制約は、ソース言語に大きな影響を及ぼす。出力結果とソース言語との対応が明確になっていなければいけない。たとえば、こんなCoffeeScriptを書いたとする。</p>
<div class="emlist-code">
<pre class="emlist">$(window).on 'touchTap', (event) -&gt;
  window.touchPanel.tap(event)
</pre>
</div>
<p>コンパイルしてできあがったJavaScriptは、ブラウザのデバッガで簡単に確認できる。</p>
<div class="emlist-code">
<pre class="emlist">$(window).on('touchTap', function(event) {
  return window.touchPanel.tap(event);
});
</pre>
</div>
<p>もう少し込み入ったCoffeeScriptを考えてみよう。たとえば、</p>
<div class="emlist-code">
<pre class="emlist">runSetupBuild: (slide, positionClass) -&gt;
  switch positionClass
    when 'current', 'next'
      @buildsFor(slide)?.setupBuild?.forwards()
      # ...
</pre>
</div>
<p>は次のようになる。</p>
<div class="emlist-code">
<pre class="emlist">Infodeck.prototype.runSetupBuild = function(slide, positionClass) {
  var _ref, _ref1, _ref2, _ref3;
  switch (positionClass) {
    case 'current':
    case 'next':
      return (_ref = this.buildsFor(slide)) != null ?
           (_ref1 = _ref.setupBuild) != null ? _ref1.forwards() : void 0
           : void 0;
    /* ... */
</pre>
</div>
<p>この変換ではいろんなことが行われているけれど、変換前後の対応関係は明確だ。デバッグする必要に迫られたとしても、ひとつひとつのコードがCoffeeScriptのどの部分に対応するのかはすぐにわかる。これこそが、コンパイルプロセスが<em>透過的</em>であるということの本質である。つまり、出力結果の言語を使って作業できるということだ<a href="#fn-f02">*2</a>。</p>
<p>それとは対照的に、ソースからソースへのコンパイラの中には変換後の言語をあまりいじってほしくなさげなものもある。出力結果をあまり見られたくなさそうなもの、とでも言えばいいだろうか。それはそれで便利で、JavaScriptの世界でもDartやGWTそしてClojureScriptといった実例がある。この<em>意図</em>の違いこそが、トランスパイルと一般的な手法とを分ける決め手だ。<a href="#fn-f03">*3</a></p>
<p>コンパイルの透過性を保つために何らかの作業が必要になるというなら、ソース言語でできることに何らかの制約が課されることになる。You don't have the degree of freedom in your language constructs that you get with a more unconstrained form of compilation. You have to follow the basic semantics of the target language, and keep to much the same program structure. These constraints haven't been widely talked about as a feature of language design.</p>
<p>CoffeeScriptは、こういった制約があったとしてもソース言語とターゲット言語の構文を大きく変えられるというよい例だ。CoffeeScriptの構文はPythonに似ており、JavaScriptがC言語風なのとは違っている。Such syntactic variation isn't always the case, indeed there is an important subset of transparent compilation languages that strive to be a superset of the target language.SCSSや<a href="http://www.typescriptlang.org" class="link">TypeScript</a>がこのタイプで、あらゆるCSSの式はSCSSとしても妥当な形式になる。スーパーセット言語を使えば対応関係はより明確になるし、CSSがより使いやすくなるだろう。個人的に、CSSの構文はよくできているけれども便利な機能に欠けるところがあるなと感じていたからだ。</p>
<p>透過的なコンパイルには意味がないという人もいる。デバッグのためにターゲット言語を理解する必要があるのなら、わざわざ別のソース言語を使う意味があるの？という意見だ。For me, the value lies in a couple of directions. First off it's a way of getting useful language features that are missing in the target language. SCSS gives me handy capabilities such as variables (so I can say <tt class="inline-code">$light-purple</tt> instead of <tt class="inline-code">#f8c8fe</tt> and change it in only one place should I want to tweak it).</p>
<p>CoffeeScriptのように構文を劇的に変えるには、それなりの理由が必要だ。One of my colleagues put it very well after finishing a project. He's an experienced JavaScript programmer and the project wrote well-disciplined JavaScript from the beginning. As a result he was very happy with the quality of the JavaScript codebase. However he still concluded that they would have been better off working in CoffeeScript, because it's easier to understand what is going on when you're reading the CoffeeScript, even when you're debugging in the generated JavaScript code. The transformation may not look like such a big deal for small fragments, such as those I show above. But it makes a big difference once you're up to hundreds of lines of code, let alone beyond.<a href="#fn-f04">*4</a></p>
<div class="footnote"><p class="footnote">[<a id="fn-f01">*1</a>] 実際に使われている場面を見る限り、「トランスパイラ（transpiler）」という用語は「ソースからソースへのコンパイラ」と同義だと思われる。なので、「透過的（transparent）」であるかどうかは関係ない。またこれ以外にも、「ソースからソースへの変換」という言い回しも見たことがある。「ソースからソースへのコンパイル」と同じ意味で使われていた。</p></div>
<div class="footnote"><p class="footnote">[<a id="fn-f02">*2</a>] 透過的でないコンパイラであっても、その生成結果を吟味する場合がある。奇妙な挙動やバグなどの原因をつきとめるため、コンパイラの生成結果を調べてみるといった場面だ。コンパイラが実際に何をしているのかを把握しようとするプログラマも中にはいる。でもそんなのはごく一部だ。</p></div>
<div class="footnote"><p class="footnote">[<a id="fn-f03">*3</a>] <a href="http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/" class="link">sourcemaps</a>が開発されたおかげでcoffeescriptのような言語から透過性がなくなってしまうのかどうか、興味深いところだ。</p></div>
<div class="footnote"><p class="footnote">[<a id="fn-f04">*4</a>] 私のcoffeescript歴は、自分のインフォデッキを作るときにほんの数百行ほど書いただけだ。でも、彼の意見には同意する。ちょっとしたコードは別として、ある程度の規模のJavaScriptを書くことになったらこれからもcoffeescriptを使い続けるだろう。</p></div>
</body>
</html>
