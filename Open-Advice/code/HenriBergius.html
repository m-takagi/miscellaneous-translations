<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:ops="http://www.idpf.org/2007/ops" xml:lang="ja">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <link rel="stylesheet" type="text/css" href="style.css" />
  <meta name="generator" content="Re:VIEW" />
  <title>Cross-Project Collaboration</title>
</head>
<body>
<h1><a id="h"></a>Cross-Project Collaboration</h1>
<p><a href="https://github.com/Open-Advice/Open-Advice/blob/master/code/HenriBergius.tex" class="link">The original text</a> (licenced under CC-BY-SA)</p>
<p class="flushright">Henri Bergius</p>
<div class="lead">
<p>Henri Bergiusは、フリーソフトウェアコンテンツのリポジトリであるMidgardの創設者だ。彼はまた、Linuxデスクトップのロケーション対応や、MaemoとMeeGoのコミュニティにも長きにわたって関わっている。Nemeinという小規模なコンサルト会社を経営し、CoffeeScriptやPHPをハックして、ユーラシア大陸の隅々までバイクで巡る。彼は現在、フィンランドのヘルシンキに住む。</p>
</div>
<blockquote><p>きっと新しいシステムがあるのだろう。そこでは単に、あなたが何者かと言うことだけが判断の基準になる。何を持っているだとか何を作ったり共有したりしただとか、それを使って周りの人たちが何を作ったかだとかは気にしない。--元Xerox PARCの所長であるJohn Seely Brown、Optimist's Tour of the Futureにて（Mark Stevenson, 2010）</p></blockquote>

<h2><a id="h-1"></a>プロジェクトとコミュニティ</h2>
<p>フリーソフトウェアの世界の大半は、何らかの「プロジェクト」に関わる人たちで構成されている。GNOMEやKDE、あるいはDrupalといた有名どころのプロジェクトもあるが、ちょっとしたアプリケーションやライブラリを扱う小さめなプロジェクトも大量に存在する。</p>
<p>でも実際のところ、こういったものを「プロジェクト」と呼ぶのはちょっとおかしい。</p>
<p>そもそもプロジェクトとは、何らかの目標を達成するための実行計画のことであり、開始日と終了予定日が定まっているものだ。たとえば「GNOME 3.1プロジェクト」というのはアリだろうが、全体としてのGNOMEを「プロジェクト」と呼ぶのはちょっと違う。これは個人のあつまるコミュニティで、ソフトウェアを作ったり保守したりといったことを、さまざまな小規模の作業やプロジェクトを通して行うものだ。</p>
<p>もったいぶった言いかたはここまでにして。プロジェクトっていう概念の何が問題かというと、それが最終的に、人を区分けしてそれぞれ別の島にまとめてしまうってことだ。お互い協力しあうこともしづらいし、できないこともある。これらのコミュニティは、結局のところはフリーソフトウェアを書く個人の集まりだ。そのソフトウェアをさまざまな環境で使えるかそうでないかも、彼ら自身が決めることになる。</p>
<p>結局のところ、私たちは自分の作ったソフトウェアを他人に使ってもらいたいものだ。あわよくば、他の人たちも自分たちのプロジェクトに巻き込んで、よりよいものを一緒に作っていきたい。それこそが、フリーソフトウェアの肝だ。</p>
<p>なのになぜ、私たちは、自分たちの周りを壁で覆ってしまうのだろう？そんなふうにコミュニティを隔離し続けると、「私たちvsそれ以外の人たち」という考えかたが生まれてしまう。各種プログラミング言語の間の非互換性のせいで私たちは既に分断されているというのに、なぜさらに分断しようとするのだろう？</p>

<h2><a id="h-2"></a>Midgardで学んだこと</h2>
<p>私がこの世界に入ったばかりのあのころ、ドットコム全盛の90年代後半に知っておきたかったことがある。実際のところ、ソフトウェア開発は自分たちだけでやる必要がないってことだ。ちょっとした注意さえ払えば、自分たちのソフトウェアやアイデアを他のコミュニティとも共有できるし、お互いのコミュニティやソフトウェアも、そのほうがずっと強力でよいものになる。</p>
<p>私がフリーソフトウェアの世界に入ったころは、巨大プロジェクトの時代だった。Netscapeがオープンソースになったり、Apache Software Foundationが設立されたりなど、ベンチャーによる出資がそこここで行われていた。とにかくやってみようよ、そして自分たちのコミュニティを作ろうよという空気があった。それこそが、名を挙げてちやほやされるための道だった。</p>
<p>で、何をしたかというと、自分たちでWebフレームワークを作ったんだ。当時はまだそれほどWebフレームワークはなかった。特に、生まれたばかりのPHP言語を使っているものなどは、ほぼなかった。最初からPHPを使おうと考えていたわけではない。開発チームのリーダーがScheme好きだったのでそれを使おうとしていたのだが、長い議論の末、PHPを使うことになった。後にPHPの評判は高まり、Web上でのプログラミングといえばPHPだというくらいの存在になった。Webこそが、私たちが作りたかったものだった。</p>
<p>最初のうちは、何も問題はなかった。多くの開発者たちがコミュニティに群がって、どんどん貢献してくれた。Midgardに出資してやろうという企業さえ現れるくらいだった。フレームワークはどんどん多機能になり、密結合になっていった。</p>
<p>今から思えば、それが間違いだった。私たちはMidgardを、PHP自体とは別のものとして扱った。個別にインストールして、その上でウェブサイトを構築するというものだ。私たちの流儀に従うか、あるいはハイウェイに乗るかだった。</p>
<p>Midgardを使う場合は、何をするときにもそのコンテンツリポジトリインターフェイスを使う必要があった。また、ユーザー管理や権限についても、その流儀に従わなければいけなかった。テンプレートシステムを使うことも強要されたし、コードの大半は、ファイルシステム上ではなくリポジトリに入れる必要があった。</p>
<p>どう見てもこれは、PHPコミュニティにうまく広まるようなものではなかった。私たちの考えかたは彼らにとっては奇妙なものだったし、当時のMidgardはPHP本体へのパッチという形式で配布されていた。というのも、PHP3にはモジュールを読み込む機能がなかったからだ。</p>
<p>あれから何年もたった。その間PHP自体の人気は一進一退を繰り返している。一方、Midgardコミュニティはずっと一貫している。小規模で密接にまとまったグループが長期的な視点で歩みを進めるが、PHPそのものの広がりとは一線を画するというものだ。</p>
<p>PHPの世界とうまくやっていくのが、なぜこんなにも難しいものなのかと、常々悩んでいた。たとえばGNOMEデスクトップコミュニティのように、ずっととっつきやすいようなコミュニティもあったのだ。ずっと孤立しっぱなしだったが、最近ようやく問題がわかった。簡単に言うと、フレームワークは別々のもの、一方ライブラリはコードや経験を共有するものだということだ。</p>

<h2><a id="h-3"></a>ライブラリとフレームワーク</h2>
<p>要するにソフトウェアとは自動化のことであり、問題を解決したり問題と問題を連携させたりするためのツールを作ることである。ソフトウェアの世界では、この手のツールはたくさんの階層にわかれている。OSのような低水準のサービスもあれば、その上で動くライブラリやフレームワークそしてツールキットなどもあり、さらにその上にはアプリケーションがある。</p>
<p>Applications are always written for some particular usecase, and so between them there are very few opportunities for sharing code.</p>
<p>The much more appealing opportunity is on the libraries and frameworks level. A framework, if generic enough, can usually be utilized for building different sorts of software. And a library can be used to bring a particular piece of logic or connectivity anywhere. In my view, this is the layer where most programming should happen, with specific applications being just something that connects various libraries into a framework that then runs the actual app.</p>
<p>What is a library and what is a framework? People often use these terms interchangeably, but there is a useful rule of thumb to know which is which: a library is something that your code calls, while a framework is something that calls your code.</p>
<p>If you want your code to be used and improved upon, the best way to go about it is to maximize the number of potential users and contributors. With free software, this works by ensuring your code can be adapted to multiple different situations and environments.</p>
<p>In the end, what you want to do is to build a library. Libraries are cool.</p>

<h2><a id="h-4"></a>How to make collaboration work</h2>
<p>The hardest part is to get over the barrier of them-versus-us. The developers of the other community are hackers building free software, just like you. So just get over the question and start talking with them.</p>
<p>After you have the discussion going, here are some points that I have found important when actually implementing common ideas or libraries across project boundaries:</p>
<ul>
<li>Use permissive licensing and try to avoid copyright assignments or other requirements potential users would find onerous.</li>
<li>Host the project on neutral ground. For web projects, Apache is quite a good home. For desktop projects, Freedesktop is probably the best option.</li>
<li>Use technologies that do not impose too many constraints. Libraries should be quite low-level, or provide D-Bus APIs that can be used with any system.</li>
<li>Avoid framework-specific dependencies. For example, KDE has found GeoClue hard to adopt because it uses GNOME-specific settings interfaces.</li>
<li>Meet the other guys. If you are from the GNOME project, go to aKademy and give a talk, and if you are a KDE developer, go and talk at GUADEC. After you have shared a beer or two collaboration over IRC happens much more naturally.</li>
<li>Finally, accept that not everybody will use your implementation. But if they at least implement the same ideas, then collaboration is still possible.</li>
</ul>
<p>Good luck with breaking down the project boundaries! In most cases it works if your ideas are good and presented with an open mind.  But even if you do not find a common ground, as long as your implementation solves the use case for you it has not been in vain. After all, delivering software, and delivering great user experience is what counts.</p>
</body>
</html>
