<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:ops="http://www.idpf.org/2007/ops" xml:lang="ja">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <link rel="stylesheet" type="text/css" href="style.css" />
  <meta name="generator" content="Re:VIEW" />
  <title>Cross-Project Collaboration</title>
</head>
<body>
<h1><a id="h"></a>Cross-Project Collaboration</h1>
<p><a href="https://github.com/Open-Advice/Open-Advice/blob/master/code/HenriBergius.tex" class="link">The original text</a> (licenced under CC-BY-SA)</p>
<p class="flushright">Henri Bergius</p>
<div class="lead">
<p>Henri Bergiusは、フリーソフトウェアコンテンツのリポジトリであるMidgardの創設者だ。彼はまた、Linuxデスクトップのロケーション対応や、MaemoとMeeGoのコミュニティにも長きにわたって関わっている。Nemeinという小規模なコンサルト会社を経営し、CoffeeScriptやPHPをハックして、ユーラシア大陸の隅々までバイクで巡る。彼は現在、フィンランドのヘルシンキに住む。</p>
</div>
<blockquote><p>きっと新しいシステムがあるのだろう。そこでは単に、あなたが何者かと言うことだけが判断の基準になる。何を持っているだとか何を作ったり共有したりしただとか、それを使って周りの人たちが何を作ったかだとかは気にしない。--元Xerox PARCの所長であるJohn Seely Brown、Optimist's Tour of the Futureにて（Mark Stevenson, 2010）</p></blockquote>

<h2><a id="h-1"></a>プロジェクトとコミュニティ</h2>
<p>フリーソフトウェアの世界の大半は、何らかの「プロジェクト」に関わる人たちで構成されている。GNOMEやKDE、あるいはDrupalといた有名どころのプロジェクトもあるが、ちょっとしたアプリケーションやライブラリを扱う小さめなプロジェクトも大量に存在する。</p>
<p>でも実際のところ、こういったものを「プロジェクト」と呼ぶのはちょっとおかしい。</p>
<p>そもそもプロジェクトとは、何らかの目標を達成するための実行計画のことであり、開始日と終了予定日が定まっているものだ。たとえば「GNOME 3.1プロジェクト」というのはアリだろうが、全体としてのGNOMEを「プロジェクト」と呼ぶのはちょっと違う。これは個人のあつまるコミュニティで、ソフトウェアを作ったり保守したりといったことを、さまざまな小規模の作業やプロジェクトを通して行うものだ。</p>
<p>もったいぶった言いかたはここまでにして。プロジェクトっていう概念の何が問題かというと、それが最終的に、人を区分けしてそれぞれ別の島にまとめてしまうってことだ。お互い協力しあうこともしづらいし、できないこともある。これらのコミュニティは、結局のところはフリーソフトウェアを書く個人の集まりだ。そのソフトウェアをさまざまな環境で使えるかそうでないかも、彼ら自身が決めることになる。</p>
<p>結局のところ、私たちは自分の作ったソフトウェアを他人に使ってもらいたいものだ。あわよくば、他の人たちも自分たちのプロジェクトに巻き込んで、よりよいものを一緒に作っていきたい。それこそが、フリーソフトウェアの肝だ。</p>
<p>なのになぜ、私たちは、自分たちの周りを壁で覆ってしまうのだろう？そんなふうにコミュニティを隔離し続けると、「私たちvsそれ以外の人たち」という考えかたが生まれてしまう。各種プログラミング言語の間の非互換性のせいで私たちは既に分断されているというのに、なぜさらに分断しようとするのだろう？</p>

<h2><a id="h-2"></a>Midgardで学んだこと</h2>
<p>私がこの世界に入ったばかりのあのころ、ドットコム全盛の90年代後半に知っておきたかったことがある。実際のところ、ソフトウェア開発は自分たちだけでやる必要がないってことだ。ちょっとした注意さえ払えば、自分たちのソフトウェアやアイデアを他のコミュニティとも共有できるし、お互いのコミュニティやソフトウェアも、そのほうがずっと強力でよいものになる。</p>
<p>私がフリーソフトウェアの世界に入ったころは、巨大プロジェクトの時代だった。Netscapeがオープンソースになったり、Apache Software Foundationが設立されたりなど、ベンチャーによる出資がそこここで行われていた。とにかくやってみようよ、そして自分たちのコミュニティを作ろうよという空気があった。それこそが、名を挙げてちやほやされるための道だった。</p>
<p>で、何をしたかというと、自分たちでWebフレームワークを作ったんだ。当時はまだそれほどWebフレームワークはなかった。特に、生まれたばかりのPHP言語を使っているものなどは、ほぼなかった。最初からPHPを使おうと考えていたわけではない。開発チームのリーダーがScheme好きだったのでそれを使おうとしていたのだが、長い議論の末、PHPを使うことになった。後にPHPの評判は高まり、Web上でのプログラミングといえばPHPだというくらいの存在になった。Webこそが、私たちが作りたかったものだった。</p>
<p>最初のうちは、何も問題はなかった。多くの開発者たちがコミュニティに群がって、どんどん貢献してくれた。Midgardに出資してやろうという企業さえ現れるくらいだった。フレームワークはどんどん多機能になり、密結合になっていった。</p>
<p>今から思えば、それが間違いだった。私たちはMidgardを、PHP自体とは別のものとして扱った。個別にインストールして、その上でウェブサイトを構築するというものだ。私たちの流儀に従うか、あるいはハイウェイに乗るかだった。</p>
<p>Midgardを使う場合は、何をするときにもそのコンテンツリポジトリインターフェイスを使う必要があった。また、ユーザー管理や権限についても、その流儀に従わなければいけなかった。テンプレートシステムを使うことも強要されたし、コードの大半は、ファイルシステム上ではなくリポジトリに入れる必要があった。</p>
<p>どう見てもこれは、PHPコミュニティにうまく広まるようなものではなかった。私たちの考えかたは彼らにとっては奇妙なものだったし、当時のMidgardはPHP本体へのパッチという形式で配布されていた。というのも、PHP3にはモジュールを読み込む機能がなかったからだ。</p>
<p>あれから何年もたった。その間PHP自体の人気は一進一退を繰り返している。一方、Midgardコミュニティはずっと一貫している。小規模で密接にまとまったグループが長期的な視点で歩みを進めるが、PHPそのものの広がりとは一線を画するというものだ。</p>
<p>PHPの世界とうまくやっていくのが、なぜこんなにも難しいものなのかと、常々悩んでいた。たとえばGNOMEデスクトップコミュニティのように、ずっととっつきやすいようなコミュニティもあったのだ。ずっと孤立しっぱなしだったが、最近ようやく問題がわかった。簡単に言うと、フレームワークは別々のもの、一方ライブラリはコードや経験を共有するものだということだ。</p>

<h2><a id="h-3"></a>ライブラリとフレームワーク</h2>
<p>要するにソフトウェアとは自動化のことであり、問題を解決したり問題と問題を連携させたりするためのツールを作ることである。ソフトウェアの世界では、この手のツールはたくさんの階層にわかれている。OSのような低水準のサービスもあれば、その上で動くライブラリやフレームワークそしてツールキットなどもあり、さらにその上にはアプリケーションがある。</p>
<p>アプリケーションは常に、何らかのユースケースに沿って書かれる。そのため、アプリケーション間でコードを共有するチャンスはめったにない。</p>
<p>コードを共有する機会がもっとありそうなのが、ライブラリやフレームワークのレベルでの話だ。十分に汎用的なフレームワークなら、通常はさまざまな種類のソフトウェアを構築するのに使えるだろう。またライブラリも、何かのロジックや接続をさまざまな場所で使えるようにできるだろう。個人的には、いちばんプログラミングをするのが、このあたりのレイヤーだと思う。さまざまなライブラリをフレームワークに組み込んで、それが実際のアプリケーションになるといったものだ。</p>
<p>いったいライブラリとは、そしてフレームワークとは何なのだろうか？この二つの言葉を同じ意味で使う人も多いが、経験上、こんなふうに判断すると便利だ。ライブラリとは、あなたが書くコードから呼び出すもの、そしてフレームワークとは、あなたが書いたコードを呼び出すもの。</p>
<p>自分のコードを使ってもらいたいだとか改良してもらいたいだとか思っているのなら、ユーザーや貢献者になってくれそうな人を可能な限り最大化するのがいちばんだ。フリーソフトウェアに関して言えば、どんな状況や環境にも対応できるようなコードを書いておけばいい。</p>
<p>要するに、あなたがやりたいのは、ライブラリを作ることだ。あれはいいものだ。</p>

<h2><a id="h-4"></a>共同作業をうまく進めるには</h2>
<p>最大の障壁は、彼ら対私たちという対立構造を乗り越えることだ。他のコミュニティに関わっている開発者たちだって、フリーソフトウェアを開発するハッカーであり、私たちと同類だ。疑うのをやめて、話をしてみよう。</p>
<p>ディスカッションを進めた後に、こんなことが重要になると気づいた。プロジェクトの境界をこえて使える共通のアイデアやライブラリを実装するためのポイントだ。</p>
<ul>
<li>Use permissive licensing and try to avoid copyright assignments or other requirements potential users would find onerous.</li>
<li>Host the project on neutral ground. For web projects, Apache is quite a good home. For desktop projects, Freedesktop is probably the best option.</li>
<li>Use technologies that do not impose too many constraints. Libraries should be quite low-level, or provide D-Bus APIs that can be used with any system.</li>
<li>Avoid framework-specific dependencies. For example, KDE has found GeoClue hard to adopt because it uses GNOME-specific settings interfaces.</li>
<li>Meet the other guys. If you are from the GNOME project, go to aKademy and give a talk, and if you are a KDE developer, go and talk at GUADEC. After you have shared a beer or two collaboration over IRC happens much more naturally.</li>
<li>Finally, accept that not everybody will use your implementation. But if they at least implement the same ideas, then collaboration is still possible.</li>
</ul>
<p>Good luck with breaking down the project boundaries! In most cases it works if your ideas are good and presented with an open mind.  But even if you do not find a common ground, as long as your implementation solves the use case for you it has not been in vain. After all, delivering software, and delivering great user experience is what counts.</p>
</body>
</html>
