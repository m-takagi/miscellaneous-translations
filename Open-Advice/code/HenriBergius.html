<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:ops="http://www.idpf.org/2007/ops" xml:lang="ja">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <link rel="stylesheet" type="text/css" href="style.css" />
  <meta name="generator" content="Re:VIEW" />
  <title>Cross-Project Collaboration</title>
</head>
<body>
<h1><a id="h"></a>Cross-Project Collaboration</h1>
<p><a href="https://github.com/Open-Advice/Open-Advice/blob/master/code/HenriBergius.tex" class="link">The original text</a> (licenced under CC-BY-SA)</p>
<p class="flushright">Henri Bergius</p>
<div class="lead">
<p>Henri Bergiusは、フリーソフトウェアコンテンツのリポジトリであるMidgardの創設者だ。彼はまた、Linuxデスクトップのロケーション対応や、MaemoとMeeGoのコミュニティにも長きにわたって関わっている。Nemeinという小規模なコンサルト会社を経営し、CoffeeScriptやPHPをハックして、ユーラシア大陸の隅々までバイクで巡る。彼は現在、フィンランドのヘルシンキに住む。</p>
</div>
<blockquote><p>きっと新しいシステムがあるのだろう。そこでは単に、あなたが何者かと言うことだけが判断の基準になる。何を持っているだとか何を作ったり共有したりしただとか、それを使って周りの人たちが何を作ったかだとかは気にしない。--元Xerox PARCの所長であるJohn Seely Brown、Optimist's Tour of the Futureにて（Mark Stevenson, 2010）</p></blockquote>

<h2><a id="h-1"></a>プロジェクトとコミュニティ</h2>
<p>フリーソフトウェアの世界の大半は、何らかの「プロジェクト」に関わる人たちで構成されている。GNOMEやKDE、あるいはDrupalといた有名どころのプロジェクトもあるが、ちょっとしたアプリケーションやライブラリを扱う小さめなプロジェクトも大量に存在する。</p>
<p>でも実際のところ、こういったものを「プロジェクト」と呼ぶのはちょっとおかしい。</p>
<p>そもそもプロジェクトとは、何らかの目標を達成するための実行計画のことであり、開始日と終了予定日が定まっているものだ。たとえば「GNOME 3.1プロジェクト」というのはアリだろうが、全体としてのGNOMEを「プロジェクト」と呼ぶのはちょっと違う。これは個人のあつまるコミュニティで、ソフトウェアを作ったり保守したりといったことを、さまざまな小規模の作業やプロジェクトを通して行うものだ。</p>
<p>もったいぶった言いかたはここまでにして。プロジェクトっていう概念の何が問題かというと、それが最終的に、人を区分けしてそれぞれ別の島にまとめてしまうってことだ。お互い協力しあうこともしづらいし、できないこともある。これらのコミュニティは、結局のところはフリーソフトウェアを書く個人の集まりだ。そのソフトウェアをさまざまな環境で使えるかそうでないかも、彼ら自身が決めることになる。</p>
<p>結局のところ、私たちは自分の作ったソフトウェアを他人に使ってもらいたいものだ。あわよくば、他の人たちも自分たちのプロジェクトに巻き込んで、よりよいものを一緒に作っていきたい。それこそが、フリーソフトウェアの肝だ。</p>
<p>なのになぜ、私たちは、自分たちの周りを壁で覆ってしまうのだろう？そんなふうにコミュニティを隔離し続けると、「私たちvsそれ以外の人たち」という考えかたが生まれてしまう。各種プログラミング言語の間の非互換性のせいで私たちは既に分断されているというのに、なぜさらに分断しようとするのだろう？</p>

<h2><a id="h-2"></a>The Midgard lesson</h2>
<p>What I wish I had known when I started, in those optimistic dot-com days of the late 90s, is that in reality software efforts do not need to be isolated. With a bit of care we can share our software and ideas across communities, making both the communities and our software stronger and better.</p>
<p>When I started my free software career, it was a time of big projects. Netscape was open-sourced, the Apache Software Foundation was getting a form, and venture-funded efforts were going on everywhere. It felt like a norm to try and build your own community. This was the sure path to fame, fortune and building cool stuff.</p>
<p>So what we did was build our own web framework. Back then there were not that many of them, especially for the fledgling PHP language. PHP was not even the first choice for us, only picked after a long debate about using Scheme which our lead developer preferred. But PHP was gaining popularity, becoming the programming language of the web. And web was what we wanted to build.</p>
<p>At first, things looked very promising. Lots of developers flocked into our community and started contributing. There were even companies founded around Midgard. And the framework became more featureful, and more tighly coupled.</p>
<p>In hindsight, this was the mistake we made. We positioned Midgard to be something apart from PHP itself. Something that you would install separately, and build whole websites on top of. It was either our way or the highway.</p>
<p>With Midgard you would have to use our content repository interfaces for everything, as well as our user management and permissions model. You would have to use our templating system, and store much of your code into the repository instead of a file system.</p>
<p>This obviously did not sit too well with the wider PHP community. Our ideas were strange to them, and Midgard at the time was even distributed as a huge patch to the codebase, as PHP3 did not have loadable modules.</p>
<p>Many years have passed, and PHP’s popularity has waxed and waned. At the same time the Midgard community has been quite constant -- a small, tightly knit group making progress in the long run, but apart from the wider PHP world.</p>
<p>We always wondered why we found it so hard to interact with the PHP world. Even some communities doing something completely different, like the GNOME desktop, seemed easier to approach. Only recently, after years of isolation, we realized the problem. In a nutshell: frameworks keep us apart, while libraries allow us to share our code and experiences.</p>

<h2><a id="h-3"></a>On libraries and frameworks</h2>
<p>In the end, software is about automation, about building tools that people can use for solving problems or connecting with each other. With software, these tools have many layers in them. There are low-level services like an operating system, then there are libraries, frameworks and toolkits, and then there are actual applications.</p>
<p>Applications are always written for some particular usecase, and so between them there are very few opportunities for sharing code.</p>
<p>The much more appealing opportunity is on the libraries and frameworks level. A framework, if generic enough, can usually be utilized for building different sorts of software. And a library can be used to bring a particular piece of logic or connectivity anywhere. In my view, this is the layer where most programming should happen, with specific applications being just something that connects various libraries into a framework that then runs the actual app.</p>
<p>What is a library and what is a framework? People often use these terms interchangeably, but there is a useful rule of thumb to know which is which: a library is something that your code calls, while a framework is something that calls your code.</p>
<p>If you want your code to be used and improved upon, the best way to go about it is to maximize the number of potential users and contributors. With free software, this works by ensuring your code can be adapted to multiple different situations and environments.</p>
<p>In the end, what you want to do is to build a library. Libraries are cool.</p>

<h2><a id="h-4"></a>How to make collaboration work</h2>
<p>The hardest part is to get over the barrier of them-versus-us. The developers of the other community are hackers building free software, just like you. So just get over the question and start talking with them.</p>
<p>After you have the discussion going, here are some points that I have found important when actually implementing common ideas or libraries across project boundaries:</p>
<ul>
<li>Use permissive licensing and try to avoid copyright assignments or other requirements potential users would find onerous.</li>
<li>Host the project on neutral ground. For web projects, Apache is quite a good home. For desktop projects, Freedesktop is probably the best option.</li>
<li>Use technologies that do not impose too many constraints. Libraries should be quite low-level, or provide D-Bus APIs that can be used with any system.</li>
<li>Avoid framework-specific dependencies. For example, KDE has found GeoClue hard to adopt because it uses GNOME-specific settings interfaces.</li>
<li>Meet the other guys. If you are from the GNOME project, go to aKademy and give a talk, and if you are a KDE developer, go and talk at GUADEC. After you have shared a beer or two collaboration over IRC happens much more naturally.</li>
<li>Finally, accept that not everybody will use your implementation. But if they at least implement the same ideas, then collaboration is still possible.</li>
</ul>
<p>Good luck with breaking down the project boundaries! In most cases it works if your ideas are good and presented with an open mind.  But even if you do not find a common ground, as long as your implementation solves the use case for you it has not been in vain. After all, delivering software, and delivering great user experience is what counts.</p>
</body>
</html>
