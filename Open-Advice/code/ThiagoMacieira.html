<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:ops="http://www.idpf.org/2007/ops" xml:lang="ja">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <link rel="stylesheet" type="text/css" href="style.css" />
  <meta name="generator" content="Re:VIEW" />
  <title>The Art of Problem Solving</title>
</head>
<body>
<h1><a id="h"></a>The Art of Problem Solving</h1>
<p><a href="https://github.com/Open-Advice/Open-Advice/blob/master/code/ThiagoMacieira.tex" class="link">The original text</a> (licenced under CC-BY-SA)</p>
<p class="flushright">Thiago Macieira</p>
<div class="lead">
<p>Thiago Macieiraは工学とMBAのふたつの学位を持つが、オープンソースにはそれ以前から関わっており、かれこれ15年のつきあいになる。KDEやQtそしてMeeGoのコミュニティに参加する彼はQtのソフトウェアエンジニアかつプロダクトマネージャーであり、講演などもしている。最近はノルウェーのオスロに住んでおり、Qtの作業をしていないときはStarCraft 2の腕を磨いている（が、なかなかうまくいかない）。</p>
</div>
<p class="noindent">私たちの日常生活は、問題で満ちあふれている。なのに、その問題を解決するためにどんなことをしているのかについては、あまり顧みられない。考えるまでもなくあっという間に正解が見つかったり、適切な処理をしたりできるほどにシンプルな問題だからなのかもしれない。解決に手間取るようになってはじめて、問題を意識する。いったん立ち止まって考える必要が出てくるからだ。専門家の場合もそれは一緒だ。プロフェッショナルな問題を解決すれば、それは職歴になる。</p>
<p>問題解決は、工学部で学び始めたときの授業のトピックのひとつでもあった。前世紀のこと。満員の講義室で700人ほとの新入生を前にして、エンジニアがどのようにして問題を解決するのかや、プロのエンジニアは問題解決を繰り返す日々を送ることなどを教授が説明した。中には、あっという間に解決できるような些細な問題もある。また、プロジェクトを立ち上げてチームで対応せざるを得ないような大きな問題もある。でも大半は、その両極端の間に位置する。教授はその後、実例を挙げて、「問題解決者」としてのメンタリティが日々の生活にどのように役立ってきたかを説明した。プロジェクターの表示がおかしくなるという、予期せぬ実例にもその場で対応していた。</p>
<p>問題解決能力は、訓練で磨き上げることのできるスキルだ。訓練とは、実際に経験し、試行錯誤をすることでしか得られないものだ。本を読んで覚えられるものではない。しかし、問題解決については、学ぶこともできる。新たな問題に直面したときの道具箱になるのがこれまでの経験だとしたら、道具箱の道具をどう使えばいいのかを書いた説明書にあたるのが、問題解決のテクニックだ。</p>

<h2><a id="h-1"></a>問いを正しく言い表す</h2>
<p>問題を解決するときの道しるべとなるのが、答えを出そうとしている問いだ。もし問い自体が間違っていれば、返ってくる答えも無意味なものになるだろうし、単に間違っているかもしれない。つまり、適切な問いかけが大切だということだ。さらに、適切な問いかけをすることで、問題解決の手がかりが得られることもある。</p>
<p>問題設定として一番無意味なのは「うまく動かない」というものだ。残念ながら、こういう問いをよく見かける。確かに動かないのだろう。何かが足りないのだから。しかし、こんな問いでは、まず何を調べればいいのかの手がかりがつかめない。</p>
<p>バグ追跡システム上でバグを報告しようとすると、「そのバグを再現する手順」「いったいどんな現象が発生したのか（いわゆる症状）」、そして「報告者が期待していた動き」を説明するよう求められる。「実際どうなったのか」と「どうなってほしかったのか」を比較すれば、よい問いが導ける。「なぜこうなったのか？」「なぜこうならなかったのか？」これが質問を作るための唯一の方法だとは言わないが、このテクニックはとてもよい助けとなるだろう。</p>
<p>問題をうまく表現して適切な問いを作るのは、問題設定をさらにきちんとするための手段でもある。まず知っておくべきことは、その問題について、今自分たちはきちんと把握しきれていないということだ。仮にきちんと把握できているのなら、おそらくその時点で問題を解決できていることだろう。問題の詳細をきちんと説明できるようになれば、助けてくれる人たちに対してよりよい情報を提供できるあらだ。さらに、直感には反するかもしれないが、問題について説明するという行為自体が、その答えの発見につながることも多い。それもあって、開発者たちの中では、「困っている」人に自分で問題を説明させてみることが多い。たとえば同僚に対して説明させたり、アヒルのおもちゃやミスター・ポテトヘッドに向かって話させたりといったことをする。</p>
<p>さらに、ときどき質問に立ち戻り、目標を見失わないようにする必要がある。問題を解決しようとしているときには、特定の部分だけに注目してしまわないよう、全体的な目で捕らえることを心がける。同じ理由で、何かの解法が見つかったときは、最初の問いをもう一度見直す必要がある。ほんとうにその解法で問題全体が解決できるのかを確かめるためだ。同じくこれは、適切な問いを発する必要性を示すものでもある。問いが不完全なら、解決策も同じく不完全になってしまう。</p>

<h2><a id="h-2"></a><i>分割統治</i></h2>
<p>他の人が問題を解決しようとしているのをオンラインで助けていると、たいていの人が問題を一枚岩の大きな塊だととらえてしまっていることがわかる。分割できず、全体を一気に片付けざるを得ないと思い込んでしまっているようだ。そのため、大規模な問題から難しい問いが生まれ、完璧に答えるのが難しくなってしまう。</p>
<p>実際、この手の問題の大半は、さらに小さな問題に分割できる。そうしたほうが個々の問題を扱いやすくなるし、根本的な原因がどれなのかも判断しやすくなる。また、言うまでもなく、過去に経験したのと同じ症状に出くわす可能性も高くなる。問題の分割を何度か繰り返せば、より取り組みやすい問題を用意することができ、すばやい解決につながる。しかし、問題を分割しようとすればするほど、システムの内部の動きを熟知しておく必要に迫られる。実際、問題解決者は、自分が知っている範囲までしか問題を分割できず、自分が分割できる範囲まで分割した時点で問題に対応していく。</p>
<p>ソフトウェア開発の場合、利用しているサブシステムを手がかりにして、問題をかみ砕いていくことが多い。たとえばTCP/IPの送信にからむ問題なら、送信側の問題と受信側の問題に分けて考えられる。送信側が適切にデータを送信できていない場合は、受信側をいくら調べたところで問題は解決しない。同様に、グラフィックアプリケーションでデータベースから取得したデータを正しく表示できないという問題も、切り分けは明確だ。まずはデータベースへのアクセスがきちんとできていることを確認してから、なぜ適切に表示されないのかを調べればいい。あるいは、適当なダミーデータを与えて表示機能を調べ、与えたデータがきちんと表示されることを先に確かめてもいい。</p>
<p>どこで切り分けたらいいのかが明確でないときでも、問題を分割してみれば、課題をあぶり出すヒントになる。分割が害になることはほとんどない。というのも、調査対象のコードは減るし、それに伴って複雑性も減少するからだ。極論を言えば、何も考えずにコードを二分割して、一方だけで問題を探してみるというのでも役立つ。いわゆる二分探索というやつだが、これは、サブシステム単位やインターフェイス単位で分けてもうまく解決できなかった場合にも使える。</p>
<p>適切に分割していけば、最終的には、問題そのものを示す小さなサンプルに行き着く。ここまできたら、次の三つのいずれかになるだろう。問題が特定できて、その場所がわかる。あるいはコード自体は正しくて、私たちが間違った思い込みをしている。または、コードそのものよりも低いレイヤーでのバグが見つかる。こういう流れを経る利点は、バグレポートを送る際に使えるテストケースができて、バグの原因をはっきりさせられるということだ。</p>

<h2><a id="h-3"></a>Boundary conditions</h2>
<p>An issue similar to dividing the problem is that of the boundary conditions. In mathematics and physics, boundary conditions are the set of values for the variables that determine the region of validity of the equations being solved. For software, boundary conditions are the set of conditions that must be met for the code to perform properly. Usually, the boundary conditions are far from simple: unlike mathematics and physics, the variables in software systems are far too many, which means that the boundary conditions for them are equally manyfold.</p>
<p>In software systems, the boundary conditions are often referred to as ``preconditions'', which are conditions that must be met before a certain action is allowed. Verifying that the preconditions have been met is a good exercise in the searching for an answer, for a violation of the preconditions is definitely a problem that needs solving -- even if it is not the root cause of the original problem. Examples of preconditions can be as simple as the fact that a pointer must be valid before it can be dereferenced or that an object must not have been disposed of before it can be used. Complex preconditions are very likely to be documented for the software being used.</p>
<p>Another interesting group of boundary conditions is characterized, interestingly, by what is not permitted: the undefined behavior. This type of boundary conditions is very common when dealing with specifications, which try to be very explicit in how software should behave. A good example of this are the compilers and language definitions. Strictly speaking, dereferencing a null pointer is an undefined behavior: the most common consequence is a processor exception being trapped and the program terminating, but other behaviors are permitted too, including working perfectly.</p>

<h2><a id="h-4"></a>The right tool for the right job</h2>
<p>If engineers are problem-solvers, the engineer’s motto is ``use the right tool for the right job''. It may seem obvious, as no one is expected to use a hammer to solve an electronic problem. Nonetheless, cases of using the wrong tool are quite common, often due to ignorance of the existence of a better tool.</p>
<p>Some of these tools are the bread-and-butter of software development, like the compiler and the debugger. Inability to use these tools is unforgivable: the professional who finds himself in an environment with new or unknown tools, such as when switching positions or jobs, must dedicate some time to learning them, becoming familiar with their functionalities and limitations. For example, if a program crashes, being able to determine the location of the crash as well as variables being accessed in that section of the code may help determine the root cause and thus point to the solution.</p>
<p>Some other tools are more advanced, belong to a niche, are not very widely known, or are available only under cost or conditions which cannot be met by the engineer. Yet they can be incredibly useful in helping elucidate problems. Such tools may be static code checker tools, thread checkers, memory debuggers, hardware event loggers, etc. For instance, development hardware often contains a way to control it via a special interface like JTAG or dump all instructions executed and processor state, but this requires having special hardware and tools, which are not readily available and usually cost more than volume, consumer devices. A different example is the valgrind suite of tools, which include thread checkers and memory debuggers and is readily available for free, but are part of the advanced, niche tools and are not taught at schools.</p>
<p>Knowing the contents of one’s toolbox is a powerful knowledge. Using a specialized tool to search for a problem will likely yield a result quicker, be it positive, confirming the problem, or negative, which in turn leads the search elsewhere. Moreover, it is important to know how to use these tools, which justifies spending time reading the documentation, in training or simply experimenting with them with known problems to understand how to proceed.</p>

<h2><a id="h-5"></a>Conclusion</h2>
<p>Solving problems is an art available to all. Like other arts, some people may have such a skill that it may seem that they were born with the ability. But in reality, with enough experience and practice, solving problems becomes an unconscious activity.</p>
<p>When faced with a problem that is not easy to solve, one should sit back and take a clear look at the entirety of the problem. What is the problem we have? Can we phrase the question that we need an answer for? Once we know what we are looking for, we can start searching for where it may be located. Can we break it down into smaller, more manageable pieces? What are the best tools to be used for each piece? Have we verified that we are using the functionalities and services correctly?</p>
<p>After solving many problems, we start to see patterns. It will become easier to detect subtle hints from the symptoms and direct the searching towards the actual problem. An experienced problem-solver may not even realize this action is taking place. That is an indication that the experience and behavior has set in so well that no conscious effort is required to access those skills.</p>
<p>Yet there are always some problems in life that will be hard to solve, ranging from professional to existential, philosophical or even those which are caused by pure curiosity. Then again, it is the challenge that drives us, the need to understand more. Life would be pretty tedious otherwise.</p>
</body>
</html>
