<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:ops="http://www.idpf.org/2007/ops" xml:lang="ja">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <link rel="stylesheet" type="text/css" href="style.css" />
  <meta name="generator" content="Re:VIEW" />
  <title>The Art of Problem Solving</title>
</head>
<body>
<h1><a id="h"></a>The Art of Problem Solving</h1>
<p><a href="https://github.com/Open-Advice/Open-Advice/blob/master/code/ThiagoMacieira.tex" class="link">The original text</a> (licenced under CC-BY-SA)</p>
<p class="flushright">Thiago Macieira</p>
<div class="lead">
<p>Thiago Macieiraは工学とMBAのふたつの学位を持つが、オープンソースにはそれ以前から関わっており、かれこれ15年のつきあいになる。KDEやQtそしてMeeGoのコミュニティに参加する彼はQtのソフトウェアエンジニアかつプロダクトマネージャーであり、講演などもしている。最近はノルウェーのオスロに住んでおり、Qtの作業をしていないときはStarCraft 2の腕を磨いている（が、なかなかうまくいかない）。</p>
</div>
<p class="noindent">私たちの日常生活は、問題で満ちあふれている。なのに、その問題を解決するためにどんなことをしているのかについては、あまり顧みられない。考えるまでもなくあっという間に正解が見つかったり、適切な処理をしたりできるほどにシンプルな問題だからなのかもしれない。解決に手間取るようになってはじめて、問題を意識する。いったん立ち止まって考える必要が出てくるからだ。専門家の場合もそれは一緒だ。プロフェッショナルな問題を解決すれば、それは職歴になる。</p>
<p>問題解決は、工学部で学び始めたときの授業のトピックのひとつでもあった。前世紀のこと。満員の講義室で700人ほとの新入生を前にして、エンジニアがどのようにして問題を解決するのかや、プロのエンジニアは問題解決を繰り返す日々を送ることなどを教授が説明した。中には、あっという間に解決できるような些細な問題もある。また、プロジェクトを立ち上げてチームで対応せざるを得ないような大きな問題もある。でも大半は、その両極端の間に位置する。教授はその後、実例を挙げて、「問題解決者」としてのメンタリティが日々の生活にどのように役立ってきたかを説明した。プロジェクターの表示がおかしくなるという、予期せぬ実例にもその場で対応していた。</p>
<p>問題解決能力は、訓練で磨き上げることのできるスキルだ。訓練とは、実際に経験し、試行錯誤をすることでしか得られないものだ。本を読んで覚えられるものではない。しかし、問題解決については、学ぶこともできる。新たな問題に直面したときの道具箱になるのがこれまでの経験だとしたら、道具箱の道具をどう使えばいいのかを書いた説明書にあたるのが、問題解決のテクニックだ。</p>

<h2><a id="h-1"></a>問いを正しく言い表す</h2>
<p>問題を解決するときの道しるべとなるのが、答えを出そうとしている問いだ。もし問い自体が間違っていれば、返ってくる答えも無意味なものになるだろうし、単に間違っているかもしれない。つまり、適切な問いかけが大切だということだ。さらに、適切な問いかけをすることで、問題解決の手がかりが得られることもある。</p>
<p>問題設定として一番無意味なのは「うまく動かない」というものだ。残念ながら、こういう問いをよく見かける。確かに動かないのだろう。何かが足りないのだから。しかし、こんな問いでは、まず何を調べればいいのかの手がかりがつかめない。</p>
<p>バグ追跡システム上でバグを報告しようとすると、「そのバグを再現する手順」「いったいどんな現象が発生したのか（いわゆる症状）」、そして「報告者が期待していた動き」を説明するよう求められる。「実際どうなったのか」と「どうなってほしかったのか」を比較すれば、よい問いが導ける。「なぜこうなったのか？」「なぜこうならなかったのか？」これが質問を作るための唯一の方法だとは言わないが、このテクニックはとてもよい助けとなるだろう。</p>
<p>問題をうまく表現して適切な問いを作るのは、問題設定をさらにきちんとするための手段でもある。まず知っておくべきことは、その問題について、今自分たちはきちんと把握しきれていないということだ。仮にきちんと把握できているのなら、おそらくその時点で問題を解決できていることだろう。問題の詳細をきちんと説明できるようになれば、助けてくれる人たちに対してよりよい情報を提供できるあらだ。さらに、直感には反するかもしれないが、問題について説明するという行為自体が、その答えの発見につながることも多い。それもあって、開発者たちの中では、「困っている」人に自分で問題を説明させてみることが多い。たとえば同僚に対して説明させたり、アヒルのおもちゃやミスター・ポテトヘッドに向かって話させたりといったことをする。</p>
<p>さらに、ときどき質問に立ち戻り、目標を見失わないようにする必要がある。問題を解決しようとしているときには、特定の部分だけに注目してしまわないよう、全体的な目で捕らえることを心がける。同じ理由で、何かの解法が見つかったときは、最初の問いをもう一度見直す必要がある。ほんとうにその解法で問題全体が解決できるのかを確かめるためだ。同じくこれは、適切な問いを発する必要性を示すものでもある。問いが不完全なら、解決策も同じく不完全になってしまう。</p>

<h2><a id="h-2"></a><i>分割統治</i></h2>
<p>他の人が問題を解決しようとしているのをオンラインで助けていると、たいていの人が問題を一枚岩の大きな塊だととらえてしまっていることがわかる。分割できず、全体を一気に片付けざるを得ないと思い込んでしまっているようだ。そのため、大規模な問題から難しい問いが生まれ、完璧に答えるのが難しくなってしまう。</p>
<p>実際、この手の問題の大半は、さらに小さな問題に分割できる。そうしたほうが個々の問題を扱いやすくなるし、根本的な原因がどれなのかも判断しやすくなる。また、言うまでもなく、過去に経験したのと同じ症状に出くわす可能性も高くなる。問題の分割を何度か繰り返せば、より取り組みやすい問題を用意することができ、すばやい解決につながる。しかし、問題を分割しようとすればするほど、システムの内部の動きを熟知しておく必要に迫られる。実際、問題解決者は、自分が知っている範囲までしか問題を分割できず、自分が分割できる範囲まで分割した時点で問題に対応していく。</p>
<p>ソフトウェア開発の場合、利用しているサブシステムを手がかりにして、問題をかみ砕いていくことが多い。たとえばTCP/IPの送信にからむ問題なら、送信側の問題と受信側の問題に分けて考えられる。送信側が適切にデータを送信できていない場合は、受信側をいくら調べたところで問題は解決しない。同様に、グラフィックアプリケーションでデータベースから取得したデータを正しく表示できないという問題も、切り分けは明確だ。まずはデータベースへのアクセスがきちんとできていることを確認してから、なぜ適切に表示されないのかを調べればいい。あるいは、適当なダミーデータを与えて表示機能を調べ、与えたデータがきちんと表示されることを先に確かめてもいい。</p>
<p>どこで切り分けたらいいのかが明確でないときでも、問題を分割してみれば、課題をあぶり出すヒントになる。分割が害になることはほとんどない。というのも、調査対象のコードは減るし、それに伴って複雑性も減少するからだ。極論を言えば、何も考えずにコードを二分割して、一方だけで問題を探してみるというのでも役立つ。いわゆる二分探索というやつだが、これは、サブシステム単位やインターフェイス単位で分けてもうまく解決できなかった場合にも使える。</p>
<p>適切に分割していけば、最終的には、問題そのものを示す小さなサンプルに行き着く。ここまできたら、次の三つのいずれかになるだろう。問題が特定できて、その場所がわかる。あるいはコード自体は正しくて、私たちが間違った思い込みをしている。または、コードそのものよりも低いレイヤーでのバグが見つかる。こういう流れを経る利点は、バグレポートを送る際に使えるテストケースができて、バグの原因をはっきりさせられるということだ。</p>

<h2><a id="h-3"></a>境界条件</h2>
<p>問題の分割に似た課題がもうひとつある。境界条件だ。数学や物理学における境界条件とは、方程式を解くときの妥当な値域を定義するものだ。ソフトウェアにおける境界条件は、コードが適切に動作するための条件群のことを指す。通常、境界条件は、シンプルとはほど遠いものになる。数学や物理学の場合と異なり、ソフトウェアシステムには大量の変動要素がある。つまり、境界条件の数もそれと同様に多くなるということだ。</p>
<p>ソフトウェアシステムにおける境界条件は「事前条件」と呼ばれることが多い。これは、何らかのアクションを許可するための前提として満たす必要がある条件という意味だ。事前条件を満たしているかどうかを確かめるというのは、答えを見つけるためのよい方法だ。事前条件に違反しているのなら、それは解決すべき問題に間違いないだろう。たとえそれが、問題の根本原因でないにしてもだ。シンプルな事前条件の例としては、「ポインタをデリファレンスする際にはそのポインタが有効でなければならない」や「オブジェクトを実際に利用する前に、破棄してはいけない」などがある。複雑な事前条件は、おそらくそのソフトウェアのドキュメントに書かれていることだろう。</p>
<p>もうひとつ、境界条件としておもしろいものがある。許可されざるもの、すなわち未定義の挙動だ。この種の境界条件は、仕様を扱う際に頻出する。仕様というものは、そもそもソフトウェアの振る舞いを明確に定めようとするものだ。よい例としては、コンパイラの仕様や言語仕様などがある。厳密に言うと、nullポインタのデリファレンスがどのような挙動になるかは未定義だ。プロセッサが例外を捕捉してプログラムが終了するというのが一般的だが、それ以外の挙動も許されており、ふつうに動き続けても問題ない。</p>

<h2><a id="h-4"></a>適切な道具で適切な仕事を</h2>
<p>エンジニアの仕事が問題解決だとしたら、そのモットーは「適切な道具を使って適切な仕事を」だ。「何を当たり前のことを言ってるんだ」と思うかもしれない。電子機器の障害にハンマーで立ち向かおうなんて人はいないだろうからね。でもみんな、道具の使いかたを間違えていることがあまりにも多い。もっと適切な道具があることに、気づけていないんだ。</p>
<p>コンパイラやデバッガのように、ソフトウェア開発において不可欠な道具もある。これらの道具が使いづらければ、とてもやっていけない。転職などで新しい道具や未知の道具を使うことになったら、プロとしては、ある程度の時間をとってその使いかたを学ぶ必要がある。どんな機能があってどんな制約があるのかを知り、慣れていくのだ。プログラムがクラッシュしたときにその場所を特定したり、クラッシュした部分からアクセスしている変数を調べたりできれば、根本原因を調べて解決に導くための助けになる。</p>
<p>ニッチな用途向けであまり知られてはいないが、もっと高度な道具もある。あるいは、コストや利用条件の関係で、エンジニアたちにはあまり縁のないような道具もある。しかしそれらだって、問題を解明するためにはとても便利なものだ。静的コードチェックツールやスレッドチェッカー、メモリデバッガ、ハードウェアイベントロガーなどが、その種の道具の一例だ。たとえば、開発用のハードウェアには、制御用の特殊なインターフェイス（JTAGなど）が用意されていることが多い。また、実行したすべての命令とプロセッサの状態をダンプできるものもある。しかし、これらを使うには、特別なハードウェアや道具が必要で、一般的なコンシューマ向け機器よりも値が張る。それ以外には、valgrindのツール群もある。ここにはスレッドチェッカーやメモリデバッガが含まれていて、フリーに使える。しかし、この手の道具の使い方は、学校では教わらない。</p>
<p>Knowing the contents of one’s toolbox is a powerful knowledge. Using a specialized tool to search for a problem will likely yield a result quicker, be it positive, confirming the problem, or negative, which in turn leads the search elsewhere. Moreover, it is important to know how to use these tools, which justifies spending time reading the documentation, in training or simply experimenting with them with known problems to understand how to proceed.</p>

<h2><a id="h-5"></a>Conclusion</h2>
<p>Solving problems is an art available to all. Like other arts, some people may have such a skill that it may seem that they were born with the ability. But in reality, with enough experience and practice, solving problems becomes an unconscious activity.</p>
<p>When faced with a problem that is not easy to solve, one should sit back and take a clear look at the entirety of the problem. What is the problem we have? Can we phrase the question that we need an answer for? Once we know what we are looking for, we can start searching for where it may be located. Can we break it down into smaller, more manageable pieces? What are the best tools to be used for each piece? Have we verified that we are using the functionalities and services correctly?</p>
<p>After solving many problems, we start to see patterns. It will become easier to detect subtle hints from the symptoms and direct the searching towards the actual problem. An experienced problem-solver may not even realize this action is taking place. That is an indication that the experience and behavior has set in so well that no conscious effort is required to access those skills.</p>
<p>Yet there are always some problems in life that will be hard to solve, ranging from professional to existential, philosophical or even those which are caused by pure curiosity. Then again, it is the challenge that drives us, the need to understand more. Life would be pretty tedious otherwise.</p>
</body>
</html>
