<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:ops="http://www.idpf.org/2007/ops" xml:lang="ja">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <link rel="stylesheet" type="text/css" href="style.css" />
  <meta name="generator" content="Re:VIEW" />
  <title>Writing Patches</title>
</head>
<body>
<h1><a id="h"></a>Writing Patches</h1>
<p><a href="https://github.com/Open-Advice/Open-Advice/blob/master/code/KaiBlin.tex" class="link">The original text</a> (licenced under CC-BY-SA)</p>
<p class="flushright">Kai Blin</p>
<div class="lead">
<p>Kai Blinは計算生物学者で、コンピューターやラボで抗生物質を探す仕事をしている。仕事で開発したソフトウェアをオープンソースライセンスのもとでリリースできたことを、うれしく思っている。ドイツ南部のテュービンゲンで暮らすKaiは、仕事以外ではSambaプロジェクトでのプログラミングにもかかわっている。その他の空き時間は、劇場で過ごすことが多い。舞台に立つこともあれば、舞台や小道具などを組み立てたりといった裏方をこなすこともある。</p>
</div>
<p class="noindent">パッチを書いて送りつけるというのは、オープンソースプロジェクトと実際に関わりを持つための第一歩だ。パッチを書けば、そのプロジェクトの開発者たちに、自分を印象づけられる。はじめてのパッチを「正しく」書くことができれば（正しいかどうかを判断するのはプロジェクト側だが）、ずっと生きやすくなるだろう。</p>
<p>パッチとはどうあるべきものなのか、パッチをプロジェクトに投げるにはどうすればいいのかといった詳細は、プロジェクトによってそれぞれ違ってくることだろう。そんな中で、どんなプロジェクトについてもあてはまる一般的なルールもある。それが、今回の主題だ。</p>

<h2><a id="h-1"></a>How to get things wrong</h2>
<p>この本は「あのとき私が知っておきたかったこと」に関するものだ。というわけで、まずは私が初めてパッチを書いたときの話をさせて欲しい。初めて実際のコーディングにかかわったのは、2005年のGoogle Summer of Code™だった。Wineプロジェクトが、Samba関連のツールを元にしたNTLM cryptoの実装を実装することを認めてくれたんだ。Wineはコミッターが1人だけのプロジェクトだ。つまり、リードデベロッパーであるAlexandre Julliardだけが、メインリポジトリへのコミット権を持つ。2005年当時、Wineはまだ、バージョン管理にCVSを使っていた。プロジェクトが始まり、私の申し出が受け入れられたというメールを受け取ったので、メンターをIRC上でつかまえて作業に入った。</p>
<p>順調にコーディングを進めて、最初のフィーチャーを実装し終えた。そこで、パッチを作ってメンターにレビューしてもらった。いにしえのCVS時代、diffのオプションは全部手で指定する必要があったのだけれど、そんなものは事前に調査済みだった。<tt class="inline-code">cvs diff -N -u &gt; ntlm.patch</tt>として作ったファイルを、メンターに送った。実際、これは正しくできたことの一つだった。パッチを作るときにまず考える必要があるのが、これだ。diffコマンドの通常の出力のほうが、機械には読みやすいのかもしれない。しかし、私はこれまで、標準の出力のほうがunified diffよりも読みやすいなどという人に出会ったことはない。<tt class="inline-code">-u</tt>フラグでunified diff形式を有効にすれば、<tt class="inline-code">$+++$</tt>と<tt class="inline-code">$---$</tt>を使ってdiffが出力されるようになる。</p>
<p>たとえば、Pythonの&quot;Hello, world!&quot;プログラムをスウェーデン語版に書き換えたときのdiffは、このようになる。</p>
<div class="emlist-code">
<pre class="emlist">diff --git a/hello.py b/hello.py
index 59dbef8..6334aa2 100644
--- a/hello.py
+++ b/hello.py
@@ -1,4 +1,4 @@
 #!/usr/bin/env python
 # vim: set fileencoding=utf-8

-print &quot;Hello, world!&quot;
+print &quot;Hallå, världen!&quot;
</pre>
</div>
<p><tt class="inline-code">-</tt>で始まる行は削除された行で、<tt class="inline-code">+</tt>で始まる行が追加された行を表す。その他の行は、<tt class="inline-code">patch</tt>コマンドが処理を行うときに使うものだ。</p>
<p>新しく作ったunified diffをメンターに送り、レビューをしてもらった。修正の指摘がたくさんあった。それを直して、新しいdiffを送り直した。GSoCの期間中、こういったコーディングとレビューを繰り返すうちに、パッチのサイズはどんどんふくれあがった。最終日になったときに手元に残ったのは、あらゆる変更が含まれた一つの巨大なパッチだった。当然、そんなパッチをレビューしてもらうのは至難の業だし、コミットする側も大変だろう。Alexandreから、パッチを分割しなければ見てやらないと言われた。Wineのポリシーとして、小規模な論理的手順で機能を追加していくパッチであるべきとされている。各パッチは、何らかの有用な内容であるだけでなく、コンパイルできる必要もある。</p>
<p>Now, splitting an existing huge patch up in pieces that individually make sense <em>and</em> compile is a lot of work. It was even more work because the only way I knew this could be done was to write a small patch, create the diff, get that committed, update my local checkout and then write the next small patch. Shortly after I started sending my first small patches, Wine went into a one month feature freeze leading up to the 0.9.0 beta release. I was sitting on my next patch for a month before I could continue, and I eventually got my last patch in in November. I was totally frustrated with the whole experience and decided I did not want to deal with the Wine community anymore.</p>
<p>My frustration held up until people who were actually using my code were starting to ask questions about it in February 2006. My code was actually useful! They wanted more features as well. When Google went on to announce it would be doing GSoC again in 2006, my plans for the summer were clear. Now that Wine had switched to git in December 2005, I knew I would not be held up by possible code freezes, as I finally could create all my small patches locally. Life was good.</p>
<p>It wasn't until I stumbled over a git frontend (called porcelain in git-speak) that emulated the ``quilt'' behavior that I learned that there were tools that could have made my life easier even in 2005.</p>

<h2><a id="h-2"></a>How NOT to get things wrong</h2>
<p>After my tale of how I managed to get things wrong with regard to sending patches, let me continue with a few tips to avoid the pitfalls.</p>

<h3><a id="h-2-1"></a>Patch submission guidelines</h3>
<p>The first tip I have is to read up on any patch submission guidelines the project you want to contribute to might have. Those should actually be consulted before you start coding, along with any coding style guidelines the project has.</p>

<h3><a id="h-2-2"></a>Unified diffs</h3>
<p>Even if not covered in the patch submission guidelines explicitly, you really, really want to send unified diff output. I have yet to meet a project that prefers the non-unified output of diff. Unified diffs make reviewing the patch so much easier. It is no accident that most modern version control programs automatically use that format in their diff command.</p>

<h3><a id="h-2-3"></a>Use distributed version control</h3>
<p>Speaking of modern version control, you will want to use a DVCS to work on the code locally. Git or Mercurial are the most popular choices there, Bazaar might be worth a look as well. Even if the project you want to contribute to still uses a centralized version control, being able to commit your changes iteratively is a great thing. All of the mentioned distributed version control tools should be able to import commits from SVN or CVS. You could go and learn quilt, but seriously, the future is in the field of distributed version control.</p>

<h3><a id="h-2-4"></a>Small patches, doing one thing at a time</h3>
<p>When I have to review patches, patches that are too big or that try to do many things at once are really annoying to deal with. Patches doing only one thing at a time are easier to review. Eventually, they will make your life easier when you finally need to debug the mistakes both the author and the reviewer of the patch missed.</p>

<h3><a id="h-2-5"></a>Track your patch</h3>
<p>After you have submitted your patch, keep an eye on the communication channels of the project and on your patch. If you have not gotten any feedback for a week, you should politely ask for feedback. Depending how the project handles patch submissions, a patch might get lost in the noise. Do not expect to get your patch committed in the first iteration. It usually takes a couple of tries to get used to the style of a new project. As a first-time contributor, nobody will blame you for this, provided you get most of the things right. Just make sure that you fix all of the things the developers indicated and send a second version of the patch.</p>

<h2><a id="h-3"></a>Conclusion</h2>
<p>Writing good patches is not hard. There are a couple of things to consider, but after writing a couple of them you should be on top of those. A modern (distributed) version control system and the workflow you get using it actually take care of most of the things I mentioned.</p>

<h3><a id="h-3-1"></a>If you remember nothing else, remember this...</h3>
<ul>
<li>Use a distributed version control system to manage your patches</li>
<li>Write patches changing code in small, self-contained steps</li>
<li>Follow the existing coding conventions</li>
<li>Respond to comments on your patch promptly</li>
</ul>
<p>The above guidelines should help you to do most if not all things right when submitting your first patches. Happy coding.</p>
</body>
</html>
