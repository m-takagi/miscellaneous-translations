<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:ops="http://www.idpf.org/2007/ops" xml:lang="ja">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <link rel="stylesheet" type="text/css" href="style.css" />
  <meta name="generator" content="Re:VIEW" />
  <title>Prepare for the Future: Evolution of Teams in FLOSS</title>
</head>
<body>
<h1><a id="h"></a>Prepare for the Future: Evolution of Teams in FLOSS</h1>
<p class="flushright">Felipe Ortega</p>
<p><a href="https://github.com/Open-Advice/Open-Advice/blob/master/research/FelipeOrtega.tex" class="link">The original text</a> (licenced under CC-BY-SA)</p>
<div class="lead">
<p>Felipe Ortegaは研究者であり、スペインのレイ・ファン・カルロス大学（URJC）の研究グループLibresoftのマネージャーである。Felipeはオープンで協力的なコミュニティ（フリーソフトウェアプロジェクトやWikipedia、ソーシャルネットワークなど）を分析するための、今までにない新たな方法論を開拓する。Wikipediaプロジェクトおよびその著者コミュニティについての、広範囲に及ぶ研究を終えた。彼は、自由ソフトウェアに関する研究やプロモーション、教育／トレーニングに積極的に参加している。彼は、オープンな教育リソースや科学出版におけるオープンアクセス、そして科学分野のオープンデータを強く支持している。</p>
</div>
<p>かの有名な<em>伽藍とバザール</em><a id="fnb-fn01" href="#fn-fn01" class="noteref">*1</a>にて、Eric S. Raymondは全プログラマーが学ぶべき第一の教訓を示している。「よいソフトはすべて、開発者の個人的な悩み解決から始まる」だ。これが正しいのかどうかは、実際に経験してみるまではなかなか実感できないものだろう。実際、FLOSSのプログラマーたち全員とは言わないまでも、多くの人たちが、これを経験しているはずだ。新しいプロジェクトで泥臭い作業をしたり、既存のプロジェクトに合流してよりよくしていくために手助けしたりといったことである。しかし、FLOSSコミュニティに参加する開発者（やドキュメンテーション作者、翻訳者など）の多くは、Raymondが同じエッセイで示すもうひとつの教訓を見落としている。「あるソフトに興味をなくしたら、最後の仕事としてそれを有能な後継者に引き渡すこと」である。ここでは、この教訓についてとりあげる。自分のプロジェクトの行く末について考え、新しく参入してきた人たちがあなたの作業を引き継げるようにしていくべきだ。</p>
<div class="footnote" id="fn-fn01"><p class="footnote">[<a href="#fnb-fn01">*1</a>] <a href="http://www.catb.org/~esr/writings/cathedral-bazaar/cathedral-bazaar" class="link">http://www.catb.org/~esr/writings/cathedral-bazaar/cathedral-bazaar</a> / <a href="http://cruel.org/freeware/cathedral.html" class="link">http://cruel.org/freeware/cathedral.html</a></p></div>

<h2><a id="h-1"></a>世代交代</h2>
<p>FLOSSプロジェクトの多くは、どこかの時点で世代交代を迫られるものだ。コードのメンテナンスや改良にかかわってきた人たちが、さまざまな理由でそのプロジェクトやコミュニティから去ることもある。個人的な問題かもしれないし、転職してプロジェクトに割くことのできる時間がなくなったのかもしれない。新しいプロジェクトを立ち上げることになったのかもしれないし、もっと魅力的な別のプロジェクトに移るのかもしれない。それ以外にも、数多くの理由が考えられる。</p>
<p>FLOSSにおける世代交代（開発者の引き継ぎ）は、今もなお活発な研究分野であり、状況を理解するためにはさらなる調査を要する。にもかかわらず、研究者の中にはすでに、これらのプロセスに光を落とす客観的証拠を集めた人もいる。OSS 2006で、同僚のJesus G. BarahonaとGregorio Roblesは&quot;Contributor Turnover in Libre Software Projects&quot;と題する発表を行った。彼らは、何かのプロジェクトについて、特定の期間内で最もアクティブな開発者（コアコントリビュータ）を特定する方法論を示したのだ。そして、その方法論を21の大規模プロジェクトに適用した。GIMPやMozilla（大昔に有名だったブラウザ）そしてEvolutionなどがその一例だ。結局、彼らが見つけたものは何だったのか。あらゆるプロジェクトは、開発者の引き継ぎの発生率によって、大きく三種類に分けられるということだ。</p>
<ul>
<li>コードの神様がまとめるプロジェクト：プロジェクトが最初の作者に強く依存しており、世代交代がほとんど（あるいはまったく）進んでいない。GIMPがこのカテゴリに属する。</li>
<li>複数世代にまたがるプロジェクト：Mozillaなどのプロジェクトでは、開発者が引退するときの作業を明示している。新たにアクティブな開発者となったグループが、かつてのコアコントリビュータから引き継ぎ、コードの開発やメンテナンスを率いている。</li>
<li>複合型プロジェクト：第三のカテゴリに属するプロジェクトも出てきつつある。引退する人もいるけれども先ほどの第二カテゴリほど明白ではなく、一部のコアコントリビュータがプロジェクトにずっと残り続けることで、影響を和らげている。</li>
</ul>
<p>この分類を見ると、ひとつ疑問がわく。「で、世間のFLOSSプロジェクトでいちばん多いパターンは、この中のどれなの？」この研究で、21のプロジェクトを調べたところ、明確な答えが出た。FLOSSのエコシステムで最も多いのは、複数の世代にまたがる複合型のプロジェクトだったのだ。初代の開発者がずっと残り続けていたのはGnumericとMonoだけだった。これらのプロジェクトに新しく参入していこうとすれば、他のプロジェクトよりも強い理由が必要になるということである。</p>
<p>にもかかわらず、これは一般的な考えとはことなる。逆に、この研究は、私たちがここで考えているアドバイスをサポートしてくれる。少なくとも今後いつかの時点で世代交代に備える必要があり、プロジェクトにおける役割やプロジェクトに関する知識を新しい参加者に引き継ぐ準備が必要であるということだ。</p>

<h2><a id="h-2"></a>知識格差</h2>
<p>人生において何か大きな変化があった場合は、誰しも新しい状況への対応を迫られる。たとえば転職した場合は、新しい場所になじんだり新しいチームとの作業に合流するために、ある程度の期間が必要になる。たいていの場合は、ある程度の時間があれば、新たな職場に落ち着けるようになるだろう。しかし時には、元の職場の同僚とも友人関係が続いて、転職後もしばしば会うかもしれない。そんな場合は、元同僚との会話の中で、かつての自分の職が今どうなっているのか、どんな人が雇われたのかを知ることになるかもしれない。FLOSSのプロジェクトにおいては、そんなことはめったに発生しない。</p>
<p>FLOSSプロジェクトにおける世代交代のマイナス点は、とてもわかりやすい形式であらわれる。知識格差だ。コミュニティ全般にわたる豊富な経験を持っていた開発者がプロジェクトを去るときには、さまざまな知識が残される。きちんと目に見えるものもあれば、暗黙知として保たれてきたものもあるだろう。それらすべてが、後任にきちんと引き継がれるかどうかはわからない。</p>
<p>わかりやすい例として、ソースコードを挙げよう。あらゆる知的生産物（少なくとも、そうであるべきだと考えているよね？）と同じく、開発者が新しくコードを書くときには、そこに開発者の意図が刻み込まれる。すばらしいプログラマーが書いたエレガントなコードを見ると、まるでコードが自ら語りかけてくるかのように思えて、メンテナンスも簡単になる。しかし時には、正反対の状況にも直面する。あいまいかつ不明瞭で、コメントも書かれていないようなコードと格闘することもあるだろう。</p>
<p>This is what we tried to measure in 2009, in a research work presented at HICSS 2009. The title is &quot;Using Software Archeology to Measure Knowledge Loss in Software Projects Due to Developer Turnover&quot;. In case you were wondering, it has nothing to do with a whip, treasures, temples or thrilling adventures, though it was really entertaining. What we measured (among other things) was the percentage of orphaned code left behind by developers who quit FLOSS projects, and not taken by any of the current developers, yet. In this case, we choose four projects (Evolution, GIMP, Evince and Nautilus) to test our research method. And we found quite interesting results.</p>
<p>Evolution exhibited a somewhat worrying pattern, in the sense that the percentage of orphaned code was growing over time. By 2006, nearly 80\% of all source code lines had been abandoned by former developers and remained untouched by the rest of the team. On the contrary, GIMP showed a radically different pattern, with a clear and sustained effort of the development team to reduce the number of orphaned lines of code. By the way, remember that GIMP had already been characterized  as a code gods project, and thus benefits from a much more stable development team to undertake this daunting task.</p>
<p>Does this mean that GIMP developers were having a much better experience than Evolution folks? To be honest, we do not know. Nevertheless, we can foresee a clear, predictable risk: the higher the percentage of orphaned code, the larger the effort to maintain the project. Whenever you need to fix a bug, develop a new feature or extend an existing one, you bump into code you had never seen before. Of course you may be a fantastic programmer, but no matter how wonderful you are, GIMP developers do have a clear advantage in this case, since they have someone in the team with precise knowledge about most of the code they need to maintain. In addition, they also work to further reduce the portion of unknown source code over time.</p>

<h2><a id="h-3"></a>It feels like home</h2>
<p>Interestingly, some projects manage to retain users for much longer periods than one could expect. Again, we can find empirical evidence supporting this claim. In OSS 2005, Michlmayr, Robles and González-Barahona presented some relevant results pertaining this aspect. They studied the persistence of participation of software maintainers in Debian, calculating the so-called half-life ratio. This is the time needed for a certain population of maintainers to fall to half of its initial size. The result was that the estimated half-life of Debian maintainers was approximately 7.5 years. In other words, since the study was undertaken over a period of six and a half years (between July 1998 to December 2004), comprising from Debian 2.0 to Debian 3.1 (only stable releases), more than 50\% of maintainers of Debian 2.0 were still contributing to Debian 3.1.</p>
<p>Debian has created quite a formal procedure to admit new software maintainers (also known as Debian developers) including the acceptance of the Debian Social Contract and showing good knowledge of Debian Policy. As a result, one would expect to have quite committed contributors. Actually this is the case, since these authors found that packages left behind by former maintainers were usually taken over by other developers staying in the community. Only in those cases in which the package was not useful anymore it was simply abandoned. I think we can learn some useful conclusions from these research works:</p>
<ol>
<li>Spend some time to develop the main guidelines of your project. It may start as a single, short document, simply featuring some recommendations and good practices. This should evolve as the project grows, to serve as a learning pill for newcomers to quickly grasp the core values of your team, as well as the main traits of your working style.</li>
<li>Force yourself to follow well-known coding standards, good practices and elegant style. Document your code. Include comments to describe sections that might be especially hard to understand. Do not feel that you are wasting your time. In practice, you are being very pragmatic, investing time in the future of your project.</li>
<li>If possible, when the time comes for you to quit the project try to make others aware of your decision some time in advance. Make sure they understand which critical parts will need a new maintainer. Ideally, if you are a community, prepare at least a very simple procedure to automate this process and make sure that you do not forget any important point before that person leaves the project (especially if she was a key developer).</li>
<li>Keep an eye on the size of orphaned code. If it rises too rapidly, or it reaches a significant proportion of your project, it is a clear indication that you will be running into trouble very soon, especially if the number of bug reports grows or you plan to revamp your code with a serious refactoring.</li>
<li>Always ensure that you leave enough tips and hints for a newcomer to take over your work in the future.</li>
</ol>

<h2><a id="h-4"></a>I wish I had known you were coming (before I quit)</h2>
<p>I admit it is not very easy to think about your successors while you are programming. Many times, you just do not realize that your code may end up being taken over by another project, reused by other people or you might eventually be replaced by another person, willing to continue your work thereafter. However, the most remarkable asset of FLOSS is precisely that one: the code will be reused, adapted, integrated or extended by someone else. Maintainability is a critical feature of software engineering. But it becomes paramount in FLOSS. It is not only about source code. It is about people, social relationships and digital etiquette. It is something beyond mere good taste. Quod severis metes (&quot;as you sow, so shall you reap&quot;). Remember that, next time, you may be the newcomer filling the knowledge gap left by a former developer.</p>
</body>
</html>
