<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:ops="http://www.idpf.org/2007/ops" xml:lang="ja">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <link rel="stylesheet" type="text/css" href="style.css" />
  <meta name="generator" content="Re:VIEW" />
  <title>テスト駆動啓発</title>
</head>
<body>
<h1><a id="h"></a>テスト駆動啓発</h1>
<p class="flushright">Jonathan &quot;Duke&quot; Leto</p>
<div class="lead">
<p>Jonathan &quot;Duke&quot; Letoはソフトウェア開発者であり、数学者としても活躍している。Git使いで自転車を愛する彼は、オレゴン州ポートランドで暮らしている。彼はParrot Virtual Machineのコア開発者であり、Leto Labs LLCの創業者でもある。</p>
</div>
<p>フリー／オープンソースソフトウェアにかかわりはじめたころは、テストとは何なのか、なぜそんなにも重要なのかが理解できなかった。それまではずっと、個人的なプログラミングだけを行っていたが、初めて他の人と共同で作業をするプロジェクトにかかわりはじめてコミット権を得たのは、Yacas（Yet Another Computer Algebra System）だった。これは、コンピュータによる代数システムで、Mathematicaに似たものだった。</p>
<p>当時の私は、テストとは後から書くものだという認識だった。「コードをハックする→ちゃんと動くかどうかを確かめる→（気が向いたら、）動いていることを証明するためのちょっとしたテストを書く」こんな感じだったのだ。テストを書くのが難しそうだなと思ったら、さっさとあきらめた。</p>
<p>これが、テスト駆動啓発への第一歩だ。おそらく、テストはよいものだということは気づいているだろう。でも、目に見えるメリットが得られないがゆえに、たまにしかテストを書かないということになってしまう。</p>
<p>ワームホールを抜けて若かりし頃の自分にアドバイスできるとしたら、きっとこう言うだろう。</p>
<blockquote><p>テストって、長い目で見れば、時にはテストされる側のコードよりも大切なこともあるんだよ。</p></blockquote>
<p>「この人、頭がおかしくなったんじゃないの？」と思った人もいるだろう。実際のコードよりも<em>テストのほうが重要だ</em>なんて、ありえないんじゃないの？テストというのは、あなたのコードが<em>実際に</em>動くことを証明するものだ。そして、テストがあれば、正しいコードを書く指針になるだけではなく、その機能を保ったままでコードを柔軟に変更できる助けにもなる。コードベースが巨大になればなるほど、テストの価値は上がる。コードの一部を変更したときにも、残りの部分がきちんと動いていることを確かめられるからだ。</p>
<p>テストを書くべき重要な理由が、もうひとつある。テストがあれば、それが期待どおりに動いている（予期せぬ副作用や、見落としていたできごとが発生していない）ことを明確にできるのだ。テストを使えば、仕様を満たしているかどうかを検証できる。これは非常に有用だし、業界によっては必須になっているところもある。テストとは、「このコードはこう動くべき」という考えを書き記した物語のようなものだ。</p>
<p>コードというものは、変更されて成長していくか、さもなければbitrot<a id="fnb-fn01" href="#fn-fn01" class="noteref">*1</a>になってしまうかのいずれかだ。</p>
<div class="footnote" id="fn-fn01"><p class="footnote">[<a href="#fnb-fn01">*1</a>] 「bitrot（ビットの腐敗）」というのはプログラマーのスラングだ。あるコード片には変更がないけれどもそれが依存する他のコードがすべて変更された場合、そのコード片は「腐敗」してしまい、たいていは、新しいソフトウェアやハードウェアに対応するための修正が必要になるという事実を指すものである。</p></div>
<p>テストを書いた後で、テスト対象の実装をリファクタリングしたり、ゼロから書き直したりすることもよくある。テスト対象のコードよりも、テストの寿命のほうが長い。つまり、コードを何度リファクタリングしようが、同じテスト群を使えるというわけだ。テストとは、リトマス試験のようなものだ。古い実装を投げ捨てても「この新しい実装のほうがずっときれいな設計だし、すべてのテストにパスしている」と言うことができる。PerlやParrotのコミュニティでは、そんなことがしょっちゅうある。そしてそこには常に私がいることを、知る人もいることだろう。</p>
<p>Tests allow you to change things quickly and know if something is broken. They are like jet packs for developers.</p>
<p>Carpenters have a bit of sage wisdom that goes like this:</p>
<blockquote><p>Measure twice, cut once.</p></blockquote>
<p>Coding is like cutting and tests are like measuring.</p>
<p>Test-Driven Enlightenment saves an enormous amount of time, because instead of flailing around, fiddling with code, not having a direction, tests hone your focus.</p>
<p>Tests also are very good positive feedback. Every time you make a new test pass, you know that your code is better and it has one more feature or one less bug.</p>
<p>It is easy to think ``I want to add 50 features'' and spend all day fiddling with code, constantly switching between working on different things. Most of the time, very little will be accomplished. Test-Driven Enlightenment guides one to focus on making one test pass at a time.</p>
<p>If you have a single failing test, you are on a mission to make it pass. It focuses your brain on something very specific, which very often has better results than switching between tasks constantly.</p>
<p>Most information about being test-driven is very specific to a language or situation, but that does not need to be the case. Here is how to approach adding a new feature or fixing a bug in any language:</p>
<ol>
<li>Write a test that fails, which you think will pass when the feature is implemented or bug is fixed. Advanced: As you write the test, run it occasionally, even if it is not done yet, and guess the actual error message that the test will give. The more tests you write and run, the easier this will become.</li>
<li>Hack on the code.</li>
<li>Run the test. If it passes, go to \#4, otherwise go to \#2.</li>
<li>You are done! Do a happy dance :)</li>
</ol>
<p>This method works for any kind of test and any language. If you remember only one thing about testing from this essay, remember the steps above.</p>
<p>Here are some more general test-driven guidelines that will serve you well and apply in almost any situation:</p>
<ol>
<li>Understand the difference between what is being tested and what is being used as a tool to test something else.</li>
<li>Fragile tests. You could write a test that makes sure an error message is exactly correct. But what happens when the error message changes? What happens when someone internationalizes your code to Catalan? What happens when someone runs your code on an operating system you have never heard of? The more resilient your test is, the more valuable it will be.</li>
</ol>
<p>Think about these things when you write tests. You want them to be resilient, i.e., tests, for the most part, should only have to change when functionality changes. If you have to change your tests often, but functionality is not changing, you are doing something wrong.</p>

<h2><a id="h-1"></a>Kinds of tests</h2>
<p>Many people start to get confused when people speak of integration tests, unit tests, acceptance tests and many other flavors of tests. One should not worry too much about these terms. The more tests you write, the more nuances you will see and the differences between tests will become more apparent. Everyone does not have the same definition for what these tests are, but the terms are still useful to describe kinds of tests.</p>

<h2><a id="h-2"></a>Unit tests vs. integration tests</h2>
<p>Unit tests and integration tests form a spectrum. Unit tests test small bits of code, and integration tests verify how more than one unit fits together. The test writer gets to decide what comprises a unit, but most often it is at the level of a function or method, although some languages call those things by different names.</p>
<p>To make this a little more concrete, we will give a basic analogy using functions. Imagine that $f(x)$ and $g(x)$ are two functions which represent two units of code. For concreteness, let's assume they represent two specific functions in your favorite Free/Open Source project's codebase.</p>
<p>An integration test asserts something like function composition, i.e., $f(g(a)) = b$. An integration test is testing how multiple things integrate or work together, instead of how a single part works individually. If algebra isn't your thing, another way to look at it is unit tests only test one part of the machine at a time, but integration tests very many parts work in unison. A great example of an integration test is test-driving a car. You are not checking the air pressure, or measuring voltage of the spark plugs. You are making sure the vehicle works as a whole.</p>
<p>Most of the time it is good to have both. I often start with unit tests and add integration tests as needed, since you will weed out the most basic bugs first, then find more subtle bugs that are related to how pieces do not quite fit together, as opposed to the individual pieces not working. Many people write integration tests first and then delve into unit tests. Which you write first is not nearly as important as writing both kinds.</p>

<h2><a id="h-3"></a>Enlightenment</h2>
<p>Test-Driven Enlightment is a path, not a place. Enjoy the journey and make sure to stop and smell the flowers if and when you get lost.</p>
</body>
</html>
