<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:ops="http://www.idpf.org/2007/ops" xml:lang="ja">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <link rel="stylesheet" type="text/css" href="style.css" />
  <meta name="generator" content="Re:VIEW" />
  <title>テスト駆動啓発</title>
</head>
<body>
<h1><a id="h"></a>テスト駆動啓発</h1>
<p class="flushright">Jonathan &quot;Duke&quot; Leto</p>
<div class="lead">
<p>Jonathan &quot;Duke&quot; Letoはソフトウェア開発者であり、数学者としても活躍している。Git使いで自転車を愛する彼は、オレゴン州ポートランドで暮らしている。彼はParrot Virtual Machineのコア開発者であり、Leto Labs LLCの創業者でもある。</p>
</div>
<p>フリー／オープンソースソフトウェアにかかわりはじめたころは、テストとは何なのか、なぜそんなにも重要なのかが理解できなかった。それまではずっと、個人的なプログラミングだけを行っていたが、初めて他の人と共同で作業をするプロジェクトにかかわりはじめてコミット権を得たのは、Yacas（Yet Another Computer Algebra System）だった。これは、コンピュータによる代数システムで、Mathematicaに似たものだった。</p>
<p>当時の私は、テストとは後から書くものだという認識だった。「コードをハックする→ちゃんと動くかどうかを確かめる→（気が向いたら、）動いていることを証明するためのちょっとしたテストを書く」こんな感じだったのだ。テストを書くのが難しそうだなと思ったら、さっさとあきらめた。</p>
<p>これが、テスト駆動啓発への第一歩だ。おそらく、テストはよいものだということは気づいているだろう。でも、目に見えるメリットが得られないがゆえに、たまにしかテストを書かないということになってしまう。</p>
<p>ワームホールを抜けて若かりし頃の自分にアドバイスできるとしたら、きっとこう言うだろう。</p>
<blockquote><p>テストって、長い目で見れば、時にはテストされる側のコードよりも大切なこともあるんだよ。</p></blockquote>
<p>「この人、頭がおかしくなったんじゃないの？」と思った人もいるだろう。実際のコードよりも<em>テストのほうが重要だ</em>なんて、ありえないんじゃないの？テストというのは、あなたのコードが<em>実際に</em>動くことを証明するものだ。そして、テストがあれば、正しいコードを書く指針になるだけではなく、その機能を保ったままでコードを柔軟に変更できる助けにもなる。コードベースが巨大になればなるほど、テストの価値は上がる。コードの一部を変更したときにも、残りの部分がきちんと動いていることを確かめられるからだ。</p>
<p>テストを書くべき重要な理由が、もうひとつある。テストがあれば、それが期待どおりに動いている（予期せぬ副作用や、見落としていたできごとが発生していない）ことを明確にできるのだ。テストを使えば、仕様を満たしているかどうかを検証できる。これは非常に有用だし、業界によっては必須になっているところもある。テストとは、「このコードはこう動くべき」という考えを書き記した物語のようなものだ。</p>
<p>コードというものは、変更されて成長していくか、さもなければbitrot<a id="fnb-fn01" href="#fn-fn01" class="noteref">*1</a>になってしまうかのいずれかだ。</p>
<div class="footnote" id="fn-fn01"><p class="footnote">[<a href="#fnb-fn01">*1</a>] 「bitrot（ビットの腐敗）」というのはプログラマーのスラングだ。あるコード片には変更がないけれどもそれが依存する他のコードがすべて変更された場合、そのコード片は「腐敗」してしまい、たいていは、新しいソフトウェアやハードウェアに対応するための修正が必要になるという事実を指すものである。</p></div>
<p>テストを書いた後で、テスト対象の実装をリファクタリングしたり、ゼロから書き直したりすることもよくある。テスト対象のコードよりも、テストの寿命のほうが長い。つまり、コードを何度リファクタリングしようが、同じテスト群を使えるというわけだ。テストとは、リトマス試験のようなものだ。古い実装を投げ捨てても「この新しい実装のほうがずっときれいな設計だし、すべてのテストにパスしている」と言うことができる。PerlやParrotのコミュニティでは、そんなことがしょっちゅうある。そしてそこには常に私がいることを、知る人もいることだろう。</p>
<p>テストがあればコードをすばやく変更できるし、どこかを壊してしまったとしてもすぐに気づける。開発者にとってのジェットパックのようなものだ。</p>
<p>大工さんたちの間では、こんな格言が知られている。</p>
<blockquote><p>二回測って、一回で切れ。</p></blockquote>
<p>コーディングが切る作業だとすれば、テストとは測ることだといえる。</p>
<p>テスト駆動啓発（Test-Driven Enlightenment）は、時間をかなり節約してくれる。方針もないままにコードを引っ掻き回すのではなく、テストのおかげで集中すべきところが明確になるからだ。</p>
<p>テストは、前向きなフィードバックとしてもすぐれている。新しいテストがパスするたびに、自分のコードがよりよくなっていることがわかるし、新しい機能が追加されたりバグが解決されたりしたこともわかる。</p>
<p>「新機能を50ほど追加したい」と考えて一日中コードを引っ掻き回し、その間他の作業の割り込みも入りまくる。よくあることだ。たいていの場合、思っていたことはほとんど達成できない。テスト駆動で進めていけば、やるべきことにひとつひとつ集中していける。</p>
<p>失敗するテストがひとつあれば、そのテストを成功させるようにすることがミッションとなる。やるべきことが明確になるので、いろんなタスクを細々と切り替えながら作業するよりもずっとよい結果になるだろう。</p>
<p>テスト駆動に関する情報は、特定の言語や状況に依存したものであることがほとんどだ。でも、必ずしもそうである必要はない。言語にかかわらず、新機能を追加したりバグを修正したりするときの流れは、次のようになる。</p>
<ol>
<li>テストを書く。このテストは、現時点では失敗するが、機能の実装やバグ修正が完了すれば成功するであろうものだ。応用：テストを書いた後は、まだ作業が完了していなくてもちょくちょく実行するといい。そして、そのテストがどんなエラーを出すかを予測してみよう。テストを書いたり実行したりを繰り返せば繰り返すほど、その手間もかからなくなるだろう。</li>
<li>コードをハックする。</li>
<li>テストを実行する。成功した場合は4.に進む。それ以外の場合は2.に戻る。</li>
<li>完成！ 小躍りしよう^^;</li>
</ol>
<p>この流れは、どんな種類のテストであろうがどんなプログラミング言語であろうが、うまく機能する。このエッセイの中でたったひとつだけ覚えておくことがあるとすれば、この手順だ。</p>
<p>もう少し一般的なテスト駆動開発の指針を示す。これは、ほぼすべての場面で適用できるものだ。</p>
<ol>
<li>テストの対象となるコードと、別の何かをテストするための道具として使うコードの違いを理解する。</li>
<li>脆いテスト（Fragile test）。エラーメッセージが正しく出力されるかどうかを確認するテストを書いたとしよう。でも、もしエラーメッセージが変わったら、そのテストはどうなるだろう？誰かがそのコードを国際化して、カタロニア語にしてしまったらどうなるだろう？誰かがそのコードを、聞いたこともないようなOS上で実行させたとしたらどうなるだろう？テストは柔軟であればあるほど価値がある。</li>
</ol>
<p>テストを書くときには、これらのことに意識しよう。テストには柔軟性を持たせたい。つまり、テストを変更するとすれば、それはテストする機能が変わったときだけであるようにしておきたい。テスト対象の機能は変わらないのに頻繁にテストを書き換える必要があるというのなら、何かが間違っている。</p>

<h2><a id="h-1"></a>テストの種類</h2>
<p>インテグレーションテストだとかユニットテストだとか受け入れテストだとか、いろんなテストの話題が出てくると、混乱してしまう人も多いだろう。別に、そういった用語を怖がる必要はない。テストをたくさん書いているうちに、これらのニュアンスの違いも何となくわかってくることだろう。これらのテストの用語について、明確な定義があるわけではない。でも、テストの種類を説明するための用語としては便利なものだ。</p>

<h2><a id="h-2"></a>ユニットテストとインテグレーションテスト</h2>
<p>ユニットテストとインテグレーションテストが、テストの両極となる。ユニットテストは小さなコード片をテストする。一方インテグレーションテストでは、複数のユニットがきちんと組み合わさるかどうかを検証する。ユニットを構成する単位はテストの作者が定めることができる。しかし、たいていの場合は、関数やメソッド（言語によっては別の呼び名があるかもしれない）のレベルに落ち着くだろう。</p>
<p>具体例として、関数を使ったアナロジーを考えてみよう。ふたつの関数f(x)とg(x)があって、これらがそれぞれひとまとまりのコードを表しているものとする。より具体的にするには、お気に入りのフリー／オープンソースプロジェクトのコードから実際にふたつの関数を選んでみるといい。</p>
<p>インテグレーションテストとは、たとえば<tt class="inline-code">f(g(a)) = b</tt>のような関数の合成を検証するものだ。インテグレーションテストは複数のものごとがうまく統合できているかどうかを確かめるものであり、単独のパーツが個別に機能することを確かめるものではない。代数が苦手な人のために、別の見方で説明しよう。ユニットテストはマシンのパーツのひとつを単独でテストするもので、インテグレーションテストはさまざまなパーツがうまく協調していることをテストするものだ。インテグレーションテストの最たる例が、自動車のテスト走行だ。タイヤの空気圧をチェックしているわけでもなく、点火プラグの電圧を確かめているわけでもない。その車が全体として機能しているかどうかを確かめているわけだ。</p>
<p>たいていの場合は、両方行うのが好ましい。私の場合はまずユニットテストから始めて、必要に応じてインテグレーションテストを足していくことが多い。個別のパーツが動かないなどといった基本的なバグをまずつぶしてしまってから、パーツ同士の組み合わせがうまくいかないなどのより細かいバグに進みたいからである。ただ、多くの人は、インテグレーションテストを書いてからユニットテストに進んでいる。どちらを先に書くかは特に重要ではなく、両方やるということこそが大切なのだ。</p>

<h2><a id="h-3"></a>Enlightenment</h2>
<p>テスト駆動啓発は道のりであって、目的地ではない。旅を楽しもう。道に迷ったときは、立ち止まって花の香りでもかいでみればいい。</p>
</body>
</html>
