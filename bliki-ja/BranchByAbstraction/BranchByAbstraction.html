<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:ops="http://www.idpf.org/2007/ops" xml:lang="ja">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <link rel="stylesheet" type="text/css" href="style.css" />
  <meta name="generator" content="ReVIEW" />
  <title>抽象化によるブランチ</title>
</head>
<body>
<h1><a id="h"></a>抽象化によるブランチ</h1>
<div class="lead">
<p>Martin Fowler's blikiの&quot;<a href="http://martinfowler.com/bliki/BranchByAbstraction.html" class="link">BranchByAbstraction</a>&quot;の翻訳。</p>
</div>
<p>2014/1/7</p>
<p class="flushright">tags: <a href="http://martinfowler.com/tags/version%20control.html" class="link">version control</a> <a href="http://martinfowler.com/tags/continuous%20integration.html" class="link">continuous integration</a></p>
<p>「抽象化によるブランチ」というテクニック<a href="#fn-fn01">*1</a>は、ソフトウェアシステムへの大規模な変更を徐々に進めていくときに使われるものだ。これを使えば、変更がまだ完了していなくても、定期的にシステムをリリースできるようになる。</p>
<p>こんな状況を考えてみよう。システムのかなりの部分が依存しているモジュール（あるいはライブラリやフレームワーク）があって、それをリプレイスしようとしている。</p>
<div class="image">
<img src="images/step-1.png" alt="" />
</div>
<p>※Flawed Supplier…欠陥のあるモジュール</p>
<p>抽象化レイヤーを作って、クライアントのコードとモジュールとのやりとりをそこに閉じ込める。クライアントのコードの中でモジュールを呼び出しているところをすべて書き換えて、この抽象化レイヤーを経由させる。</p>
<div class="image">
<img src="images/step-2.png" alt="" />
</div>
<p>各クライアントについて、この抽象化レイヤーを使うよう徐々に書き換えていく。そして最終的には、モジュールとのやりとりをすべて抽象化レイヤーに閉じ込める。こうすることで、モジュールに対するユニットテストのカバレッジを改善できるようになる。この抽象化レイヤーをテスト通してテストできるからだ。</p>
<div class="image">
<img src="images/step-3.png" alt="" />
</div>
<p>そして、クライアントに必要な機能を実装した新しいモジュールを作る。このとき、新しいモジュールも先ほどの抽象化レイヤーを使うようにする<a href="#fn-fn02">*2</a>。準備が整ったら、その機能を使うクライアントのコードを変更し、新しいモジュールを使うように切り替える。</p>
<div class="image">
<img src="images/step-4.png" alt="" />
</div>
<p>それ以外のクライアントについても、問題のあるモジュールから新しいモジュールへ徐々に切り替えていく。古いモジュールが不要になった時点で、古いモジュールは削除できる。この移行作業が終わったら、抽象化レイヤーはそのままでもかまわないし消してしまってもかまわない。</p>
<div class="image">
<img src="images/step-5.png" alt="" />
</div>
<p>この例はあくまでも一般的なものだが、実際はいろんなバリエーションがあり得る。一部のクライアントだけを先に移行するのが不可能で、全部一括で移行せざるを得ないことだってあるだろう。あるいは、元のモジュールをいくつかのサブコンポーネントに分割して、サブコンポーネント単位で先ほどのプロセスを繰り返すことも考えられる。</p>
<p>こういったバリエーションがあるにせよ、その狙いはすべて共通している。抽象化レイヤーを使って、複数の実装を一つのソフトウェアシステム内で共存できるようにすることだ。抽象化レイヤーを一枚増やすことで、一つの実装からもう一つの実装への移行を行っている。どの時点であってもシステムがきちんとビルドできて実行できることが保証されているので、<a href="http://martinfowler.com/delivery.html" class="link">継続的デリバリー</a>を実現しながらリプレイスを進められる。段階的な変更の進めかたについては、いろんな方法を探ってみよう。</p>

<h2><a id="h-1"></a>Further Reading</h2>
<p><a href="http://continuousdelivery.com/2011/05/make-large-scale-changes-incrementally-with-branch-by-abstraction/" class="link">Jez Humble describes</a> how his team used Branch-by-Abstraction to replace both an object-relational mapping framework (ibatis to hibernate) and the web UI framework (velocity/JsTemplate to Ruby on Rails) for ThoughtWorks's Continuous Delivery tool &quot;Go&quot;.</p>
<p>Paul Hammant provides <a href="http://paulhammant.com/blog/branch_by_abstraction.html" class="link">more details</a> of using Branch-by-Abstraction, particularly as an alternative to using version-control branching.</p>

<h2><a id="h-2"></a>Acknowledgements</h2>
<p>Thanks to Paul Hammant for his detailed suggestions as well as being an important primary source.</p>

<h2><a id="h-3"></a>Notes</h2>
<div class="footnote"><p class="footnote">[<a id="fn-fn01">*1</a>] このテクニックは別に目新しいものではないが、これまできちんと名付けられたことがなかった。「抽象化によるブランチ」という言葉を使い始めたのはPaul Hammantで、<a href="http://paulhammant.com/2013/04/05/what-is-trunk-based-development/" class="link">Trunkでの開発</a>よりもずっといいと主張した（彼曰く、もともとはStacy Curlが思いついた言葉だそうだ）。今やこの用語は一般的になり、よく効くようになった。</p></div>
<div class="footnote"><p class="footnote">[<a id="fn-fn02">*2</a>] While we are building the new feature we can use <a href="http://martinfowler.com/FeatureToggle.html" class="link">FeatureToggles</a> to run the new supplier in test environments and compare its behavior to the flawed supplier.</p></div>
</body>
</html>
