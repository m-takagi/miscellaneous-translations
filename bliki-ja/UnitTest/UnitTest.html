<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:ops="http://www.idpf.org/2007/ops" xml:lang="ja">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <link rel="stylesheet" type="text/css" href="style.css" />
  <meta name="generator" content="Re:VIEW" />
  <title>UnitTest</title>
</head>
<body>
<h1><a id="h"></a>UnitTest</h1>
<div class="lead">
<p>Martin Fowler's blikiの&quot;<a href="http://martinfowler.com/bliki/UnitTest.html" class="link">UnitTest</a>&quot;の翻訳。</p>
</div>
<p>2014/5/5</p>
<p>ソフトウェア開発において、ユニットテスティングの話題になることが多い。私がプログラムを書きはじめて以来ずっと、ユニットテスティングという言葉はおなじみだった。しかし、ソフトウェア開発用語の常として、ユニットテスティングという用語もきちんと定義できていない。ユニットテスティングという用語の意味を実際よりも厳密にとらえてしまったせいで、混乱してしまっている人もよく見かける。</p>
<div class="image">
<img src="images/sketch.png" alt="" />
</div>
<p>もちろんそれ以前からもユニットテスティングはやってきていたのだが、それを人前で公表したのは、Kent Beckと仕事をして<a href="http://martinfowler.com/bliki/Xunit.html" class="link">Xunit</a>系のツールを使い始めたころのことだった（この種のテストのことは、ユニットテスティングっていうより「xunitテスティング」って呼んだほうがいいと思うんだ）。ユニットテスティングはその後<a href="http://martinfowler.com/bliki/ExtremeProgramming.html" class="link">ExtremeProgramming</a>（XP）の看板アクティビティとなり、そして<a href="http://martinfowler.com/bliki/TestDrivenDevelopment.html" class="link">TestDrivenDevelopment</a>が誕生した。</p>
<p>XPが始まった頃から、XP界での「ユニットテスティング」の定義には懸念があった。当時のusenetでの議論を思い出す。XPな人たちが、テスティングのエキスパートたちに「おまえたちは『ユニットテスト』という言葉の意味をはき違えている」とつるし上げられたんだ。「じゃあ、本当の意味を教えてくださいな」というと、答えは「ワシの研修に参加しろ。午前中に、ユニットテストの24の定義を教えてやろう」みたいな感じだった。</p>
<p>定義はひとそれぞれだが、共通するところもいくつかある。まず、ユニットテストは詳細レベルのテストで、ソフトウェアシステムの小さなパーツを対象とするものだ。次に、ユニットテストは通常、普段使っているツールを用いてプログラマー自身が書くものだ。なんらかのユニットテスティングフレームワークを使うことがあるかもしれない<a href="#fn-fn01" class="noteref">*1</a>。そして、ユニットテストは、他のテストよりもすばやく実行できるものと見なされている。</p>
<p>こんなふうに共通する部分もあれば、それぞれ違っている部分もある。違う部分のひとつとして挙げられるのが、何をもって<i>ユニット</i>とするのかという点だ。オブジェクト指向設計では、ひとつのクラスを「ユニット」と扱うことが多い。一方、手続き型や関数型のアプローチでは、ひとつの関数を「ユニット」と見なすかもしれない。でも、実際のところ、これは状況によるものだ。何を「ユニット」と見なすのかは、チームがそのシステムやテストをどのように理解しているのかに応じて決めるものだ。私は、とりあえずひとつのクラスを「ユニット」として始めたいと思っているが、関連するクラス群を一括で「ユニット」と扱うこともよくある。逆に、ひとつのクラスの中の一部のメソッドだけを「ユニット」とすることは、めったにない。これはあくまでも私の考えなので、他の人がどう思うかは特に気にしない。</p>

<h2><a id="h-1"></a>分離</h2>
<p>もっと重要な違いがある。テスト対象のユニットを、他のコンポーネントから分離すべきか否かというところだ。orderクラスのpriceメソッドをテストしているとしよう。priceメソッドの内部では、productクラスやcustomerクラスの機能を実行する必要がある。他のコンポーネントから分離するという原則に従うなら、ここで実際のproductクラスやcustomerクラスを使うのは避けたい。たとえばcustomerクラスの挙動に問題があったときに、orderクラスのテストも失敗してしまうからだ。そんな時には、実際のコンポーネントの代わりに<a href="http://martinfowler.com/bliki/TestDouble.html" class="link">テストダブル</a>を使う。</p>
<div class="image">
<img src="images/isolate.png" alt="" />
</div>
<p>でも、ユニットテストでわざわざそんなことはしない、という人もいる。実際、90年代にxunitテスティングが始まったころは、よっぽどのことがない限りこんな細工はしなかった（「よっぽどのこと」とは、たとえば外部のクレジット審査システムを使っているなどの場合だ）。たとえテスト対象以外のところが問題でテストが失敗していたとしても、その原因を探るのはそれほど苦にならないと考えられていた。なので、実際のところ、わざわざ分離するほどの問題だとは思わなかったのだ。</p>
<p>分離を気にしなかったことも、当時「おまえらのユニットテスティングは間違っている」と批判された原因のひとつだろう。でも私は、それもまた「ユニットテスティング」だと思っていた。だって、単体のユニットの振る舞いをテストしているという点では同じなのだから。私たちは、テスト対象のユニット以外はすべて正常に動くものだという前提のもとで、テストを書いている。</p>
<p>2000年代に入ってxunitテスティングがはやりだしたころに、分離主義がふたたび登場してきた。モックオブジェクトや、モッキングをサポートするフレームワークが現れたのだ。xunitテスティングは二つの学派に分裂した。私は両者を<a href="http://martinfowler.com/articles/mocksArentStubs.html" class="link">古典派そしてモック主義者と呼んでいる</a>。古典派のxunitテスターは分離など気にしないが、モック主義者は分離を気にする。どちらの考えかたも理解できるし、どちらの考えかたも尊重している（ただ、個人的には、古典派の考えに近い）。</p>
<p>私みたいな古株のテスターだって、扱いづらい外部コンポーネントがあればテストダブルを使う。<a href="http://martinfowler.com/articles/nonDeterminism.html#RemoteServices" class="link">リモートサービスとの通信時の非決定論</a>を取り除けるという価値は計り知れない。古典主義者の中にも、データベースやファイルシステムなどの外部リソースについてはテストダブルを使うべきだと主張する人がいる。非決定論のリスクや、スピードのリスクを考慮した意見だ。有用な指針だとは思うが、私は「外部リソースにはテストダブルを使う」と絶対的に決めてしまう気にはならない。そのリソースが十分に安定していて、かつ高速にやりとりできるのなら、ユニットテストで直接それを使わない理由はないと思っている。</p>

<h2><a id="h-2"></a>スピード</h2>
<p>ユニットテストに共通する性質（スコープが小さい、プログラマー自身が実行する、高速に行う）はつまり、プログラミングの際に頻繁にユニットテストを実行できるということを意味する。実際これは、<a href="http://martinfowler.com/bliki/SelfTestingCode.html" class="link">SelfTestingCode</a>の鍵となる特性でもある。プログラマーは、コードに変更を加えるたびにユニットテストを実行する。私の場合は、コンパイルできるコードがあるときにはいつもテストを実行するので、実行頻度は1分間に数回のレベルになる。もし間違ってどこかを壊してしまったときには、すぐに気づけるようにしたいからだ。不具合の原因となった変更の直後にその不具合に気づければ、バグを見つけるのもたやすくなる。今いじったところだけを見ればいいわけだ。</p>
<p>このように高速にユニットテストを回すときには、必ずしも毎回すべてのテストを実行しなくてもかまわない。通常は、今作業中のコード周りのテストだけを実行すればいいだろう。テストの深さをある程度犠牲にして、テストスイートの実行時間を取ることになる。私はこの手のテストスイートを<b>コンパイルスイート</b>と呼ぶ。「コンパイルしようかな」と思ったとき（Rubyみたいなインタプリタ型の言語でも同じだ）に常に実行するからだ。</p>
<p>継続的インテグレーションを使っているなら、テストスイートもその一環で実行すべきだ。このときの使うテストスイート（私は<b>コミットスイート</b>と呼ぶ）には、すべてのユニットテストを含めるのが一般的だ。それ以外に、いくつかの<a href="http://martinfowler.com/bliki/BroadStackTest.html" class="link">BroadStackTests</a>を含めることもある。プログラマーとして、このコミットスイートは1日に何度か実行すべきだ。バージョン管理システムへのコミットの前に行うのはもちろん、それ以外の場合でも、たとえば休憩前や打ち合わせに出る前などに行うといい。コミットスイートの実行速度が上がれば上がるほど、より頻繁に実行できるようになる。<a href="#fn-fn02" class="noteref">*2</a></p>
<p>ユニットテストやテストスイートの実行速度については、人によっていろんな意見がある。<a href="http://david.heinemeierhansson.com/2014/slow-database-test-fallacy.html" class="link">David Heinemeier Hansson</a>は、コンパイルスイートが数秒で実行できて、コミットスイートが数分で終わるようなら問題ないと考えている。<a href="https://www.destroyallsoftware.com/blog/2014/tdd-straw-men-and-rhetoric" class="link">Gary Bernhardt</a>は、それでは我慢できないようだ。コンパイルスイートは300ms程度で実行できるべきだと言う。また、<a href="http://dan.bodar.com/2012/02/28/crazy-fast-build-times-or-when-10-seconds-starts-to-make-you-nervous/" class="link">Dan Bodart</a>は、コミットスイートに10秒以上かけたくないとしている。</p>
<p>絶対的な答えがあるとは思っていない。コンパイルスイートが1秒以内で終わろうが数秒かかろうが、個人的にはあまり差がないと思っている。私はKent Beckの経験則（コミットスイートは10分以内で実行できるべき）を好む。が、その本質は、頻繁に実行するのが苦にならない程度に、テストを高速に実行できるべきだということだ。そして、「頻繁に」というのは、最小限の手間で手早くバグを見つけられる程度にということだ。</p>

<h2><a id="h-3"></a>備考</h2>
<div class="footnote"><p class="footnote">[<a id="fn-fn01">*1</a>] I say &quot;these days&quot; because this is certainly something that has changed due to XP. In the turn-of-the-century debates, XPers were strongly criticized for this as the common view was that programmers should never test their own code. Some shops had specialized unit testers whose entire job would be to write unit tests for code written earlier by developers. The reasons for this included: people having a conceptual blindness to testing their own code, programmers not being good testers, and it was good to have a adversarial relationship between developers and testers. The XPer view was that programmers could learn to be effective testers, at least at the unit level, and that if you involved a separate group the feedback loop that tests gave you would be hopelessly slow. Xunit played an essential role here, it was designed specifically to minimize the friction for programmers writing tests.</p></div>
<div class="footnote"><p class="footnote">[<a id="fn-fn02">*2</a>] If you have tests that are useful, but take longer than you want the commit suite to run, then you should build a <a href="http://martinfowler.com/bliki/DeploymentPipeline.html" class="link">DeploymentPipeline</a> and put the slower tests in a later stage of the pipeline.</p></div>
</body>
</html>
